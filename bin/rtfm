#!/usr/bin/env ruby
# frozen_string_literal: true

# SCRIPT INFO {{{1
# Name:       RTFM - Ruby Terminal File Manager
# Language:   Pure Ruby, best viewed in VIM
# Author:     Geir Isene <g@isene.com>
# Web_site:   http://isene.com/
# Github:     https://github.com/isene/RTFM
# License:    I release all copyright claims. This code is in the public domain.
#             Permission is granted to use, copy modify, distribute, and sell
#             this software for any purpose. I make no guarantee about the
#             suitability of this software for any purpose and I am not liable
#             for any damages resulting from its use. Further, I am under no
#             obligation to maintain or extend this software. It is provided
#             on an 'as is' basis without any expressed or implied warranty.
# Docs:       Apart from the extensive documentation found on Github, you can
#             get a great understanding of the code itself by simply sending
#             or pasting this whole file into you favorite AI for coding with
#             a prompt like this: "Help me understand every part of this code".
@version    = '5.8.1' # Minor adjustment to max image width

# SAVE & STORE TERMINAL {{{1
ORIG_STTY = `stty -g`.chomp

at_exit do
  system("stty #{ORIG_STTY} < /dev/tty") rescue nil
end

# BOOTSNAP {{{1
cache_dir = ENV.fetch('BOOTSNAP_CACHE_DIR', File.join(Dir.home, '.rtfm', 'bootsnap-cache'))
ENV['BOOTSNAP_CACHE_DIR'] = cache_dir
require 'fileutils'
FileUtils.mkdir_p(cache_dir)
require 'bootsnap/setup' # Speed up subsequent requires

# ENCODING {{{1
# encoding: utf-8

# PROFILER {{{1
#$start_time      = Process.clock_gettime(Process::CLOCK_MONOTONIC)
#$last_checkpoint = $start_time
#$checkpoints     = []
#def checkpoint(label)
#  now      = Process.clock_gettime(Process::CLOCK_MONOTONIC)
#  delta_ms = ((now - $last_checkpoint) * 1000).round(2)
#  total_ms = ((now - $start_time)     * 1000).round(2)
#  $checkpoints << "#{label.ljust(20)}: #{delta_ms} ms"
#  $checkpoints.reject! { |line| line.start_with?("Total:") }
#  $checkpoints << "Total: #{total_ms} ms"
#  $last_checkpoint = now
#end

# LOAD LIBRARIES {{{1
begin
  require 'rcurses'
  class Object
    include Rcurses
    include Rcurses::Input
  end
rescue StandardError => e
  puts 'RTFM is built using rcurses (https://github.com/isene/rcurses). Install rcurses to run RTFM.'
  exit 1
end
require 'tmpdir'
# Lazy-load to speed up startup
autoload :Shellwords, 'shellwords'
autoload :Timeout,    'timeout'
autoload :Open3,      'open3'
autoload :PTY,        'pty'
autoload :OpenAI,     'ruby/openai'
#checkpoint("Libraries loaded")

# FIX TERMINAL MESSAGE BLEED-THROUGH {{{1
LOG_PATH     = File.join(Dir.tmpdir, 'rtfm.log')
MAX_LOG_SIZE = 128 * 1024
if File.exist?(LOG_PATH) && File.size(LOG_PATH) > MAX_LOG_SIZE
  # keep just the last MAX_LOG_SIZE bytes
  File.open(LOG_PATH, 'r+b') do |f|
    f.seek(-MAX_LOG_SIZE, IO::SEEK_END)
    tail = f.read
    f.rewind
    f.truncate(0)
    f.write(tail)
  end
end
logfile = File.open(LOG_PATH, 'a+')
logfile.sync = true
$stderr.reopen(logfile)
#checkpoint("Bleed-through fix")

# RCURSES CLASS EXTENSION {{{1
module Rcurses
  # Add attributes, amend 'say' to set update to false
  class Pane
    attr_accessor :update, :locate
    alias original_say say
    def say(text)
      original_say(text)
      self.update = false
    end
  end
end

# CREATE DIRS & SET FILE CONSTS {{{1
RTFM_HOME     = File.join(Dir.home, '.rtfm')
PLUGINS_DIR   = File.join(RTFM_HOME, 'plugins')
TRASH_DIR     = File.join(RTFM_HOME, 'trash')
[RTFM_HOME, PLUGINS_DIR, TRASH_DIR].each { |d| FileUtils.mkdir_p(d) }
PREVIEW_FILE  = File.join(RTFM_HOME, 'preview.rb')
KEYS_FILE     = File.join(RTFM_HOME, 'keys.rb') unless defined?(KEYS_FILE)
CONFIG_FILE   = File.join(RTFM_HOME, 'conf')
@plugin_errors = []

# HELP {{{1
@help = <<~HELPTEXT
  RTFM - Ruby Terminal File Manager (https://github.com/isene/RTFM)

  BASIC KEYS
    ?       = Show this help text
    v       = Display RTFM version (and latest Gem version) in bottom window/command bar
    r       = Refresh RTFM (recreates all windows. Use on terminal resize or when there is garbage somewhere)
    R       = Reload configuration (~/.rtfm/conf)
    W       = Write parameters to ~/.rtfm/conf: @marks, @hash, @history, @rubyhistory, @aihistory
              @lslong, @lsall, @lsorder, @lsinvert, @width, @border, @preview, @trash
    C       = Show the current configuration in ~/.rtfm/conf
    q       = Quit (save basic configuration: @marks, @hash, @history, @rubyhistory, @aihistory)
    Q       = QUIT (without writing any changes to the config file)

  LAYOUT
    w       = Change the width of the left/right panes (left pane ⇒ 20%, 30%, 40%, 50%, 60%)
    B       = Cycle border
    -       = (Minus sign) Toggle preview in right pane (turn it off for faster traversing of directories)
    _       = (Underscore) Toggle preview of images in right pane
    b       = Toggle syntax highlighting (and line numbering)

  MOTION
    j/DOWN  = Go one item down in left pane (rounds to top)
    k/UP    = Go one item up in left pane (rounds to bottom)
    h/LEFT  = Go up one directory level
    l/RIGHT = Enter directory or open file (using run-mailcap or xdg-open)
              Use the key 'x' to force open using xdg-open (or run-mailcap) - used for opening html files
              in a browser rather than editing the file in your text editor
    PgDown  = Go one page down in left pane
    PgUp    = Go one page up in left pane
    END     = Go to last item in left pane
    HOME    = Go to first item in left pane

  MARKS AND JUMPING
    m       = Mark current dir (persistent). Next letter is the name of the mark [a-zA-Z']
              The special mark "'" jumps to the last directory (makes toggling dirs easy)
              Press '-' and a letter to delete that mark. Mark '0' is the dir where RTFM was started.
              Marks '1' - '5' are the past five directories visited.
    M       = Show marked items in right pane
    '       = Jump to mark (next letter is the name of the mark [a-zA-Z'])
              The 5 latest directories visited are stored in marks 1-5 (1 being the very latest)
    ~       = Jump to Home directory
    >       = Follow symlink to the directory where the target resides

  DIRECTORY VIEWS
    a       = Show all (also hidden) items
    A       = Show long info per item (show item attributes)
    o       = Change the order/sorting of directories (circular toggle)
    i       = Invert/reverse the sorting
    O       = Show the Ordering in the bottom window (the full ls command)

  TAGGING
    t       = Tag item (toggles)
    Ctrl-t  = Add items matching a pattern to list of tagged items (Ctrl-t and then . will tag all items)
    T       = Show currently tagged items in right pane
    u       = Untag all tagged items

  MANIPULATE ITEMS
    p       = Put (copy) tagged items here
    P       = PUT (move) tagged items here
    c       = Change/rename selected (adds command to bottom window)
    s       = Create symlink to tagged items here
    d       = Delete selected item and tagged items. Confirm with 'y'. 
              Moves items to trash directory (~/.rtfm/trash/) if @trash = true
    D       = Empty trash directory
    Ctrl-d  = Toggle use of trash directory
    Ctrl-o  = Change ownership to user:group of selected and tagged items
    Ctrl-p  = Change permissions of selected and tagged items
              Format = rwxr-xr-x or 755 or rwx (applies the trio to user, group and others)

  FILTER AND SEARCH
    f       = Show only files in the left pane matching extension(s) (e.g. "txt" or "pdf,png,jpg")
    F       = Show only files matching a pattern (Ruby Regex) (e.g. "abc" or "ab.+12(\w3)+")
    Ctrl-f  = Clear all filtering
    /       = Enter search string in bottom window to highlight matching items and jump to the first match
    \\       = Remove search pattern
    n       = Jump to the next item matched by '/'
    N       = Jump to the previous item matched by '/'
    g       = Run 'grep' to show files that contains the MATCH in current directory
    L       = Start 'locate' search for files, then use '#' to jump to desired line/directory
    Ctrl-l  = Locate files via fzf from the current directory down
              (fuzzy file finder must be installed https://github.com/junegunn/fzf)

  ARCHIVES
    z       = Extract tagged zipped archive to current directory
    Z       = Create zipped archive from tagged files/directories

  GIT/HASH/OPENAI
    G       = Show git status for current directory
    H       = Do a cryptographic hash of the current directory with subdirs
              If a previous hash was made, compare and report if there has been any change
    I       = Show OpenAI's description of the selected item and its content (if available)
              You must have installed the ruby-openai gem and added your openai secret key
              in the ~/.rtfm/conf (add `@ai = "your-secret-openai-key") for this to work.
    Ctrl-a  = Start an OpenAI chat (the context window is kept until you exit RTFM)
              The OpenAI agent is specialized in answering questions about cli, files and dirs

  RIGHT PANE CONTROLS
    ENTER   = Refresh the right pane
    S-RIGHT = One line down in the preview
    S-LEFT  = One line up in the preview
    S-DOWN  = Next page of the preview (if doc long and ∇ in the bottom right) (TAB does the same)
    S-UP    = Previous page (if you have moved down the document first - ∆ in the top right) (or S-TAB)

  CLIPBOARD COPY
    y       = Copy path of selected item to primary selection (for pasting with middle mouse button)
    Y       = Copy path of selected item to clipboard
    Ctrl-y  = Copy content of right pane to clipboard
              Turn off batcat syntax highlighting with 'b' for a clean copy of content

  SYSTEM SHORTCUTS
    S       = Show comprehensive System info (system, CPU, filesystem, latest dmesg messages)
    =       = Create a new directory (a shortcut for ":mkdir ")
    Ctrl-n  = Invoke navi (see https://github.com/denisidoro/navi) with any output in right window

  COMMAND MODE
    :       = Enter "command mode" in bottom window (press ENTER to execute, press ESC to escape)
              Prefix the command with a '§' to force the program to run in interactive mode
              Full screen TUI programs like htop, vim or any shell must run in interactive mode
    ;       = Show command history in right pane
    +       = Add program(s) to the list of full-UI interactive terminal programs

  RUBY DEBUG MODE
    @       = Enter Ruby mode to execute any Ruby command (ENTER to execute, ESC to escape)

  COPYRIGHT: Geir Isene, 2025+. No rights reserved. See http://isene.com for more.
HELPTEXT

# FIRST RUN # {{{1
def firstrun # {{{2
  setup_launch_script
  setup_config
  load_config
  setup_templates
  display_welcome_message
  getchr
rescue StandardError => e
  errormsg('⚠ Errors during RTFM first-run.', e)
  exit 1
end

def setup_launch_script # {{{2
  shell_name = File.basename(ENV['SHELL'].to_s)
  if shell_name == 'fish'
    fish_cfg = File.join(Dir.home, '.config', 'fish', 'config.fish')
    FileUtils.mkdir_p(File.dirname(fish_cfg))
    line = 'function r; rtfm; cd (cat ~/.rtfm_last_dir); end # rtfm launcher'
    File.write(fish_cfg, "#{line}\n", mode: 'a')
  else
    rc_file = File.join(Dir.home, ".#{shell_name}rc")
    FileUtils.mkdir_p(File.dirname(rc_file))
    line = 'r(){ rtfm; cd "$(cat ~/.rtfm_last_dir)"; } # rtfm launcher'
    File.write(rc_file, "#{line}\n", mode: 'a')
  end
end

def setup_config # {{{2
  File.write CONFIG_FILE, <<~CONFIG
    # Configuration file for RTFM (https://github.com/isene/RTFM)
    # BASICS
    @width       = 2
    @border      = 1
    @trash       = true

    # LS
    @lslong      = ""
    @lsall       = ""
    @lsorder     = ""
    @lsinvert    = ""

    # RIGHT PANE
    @runmailcap  = true
    @preview     = true
    @showimage   = true

    # TOP PANE
    @topmatch = [["", 249]]

    # INTERACTIVE
    @interactive = "fzf,navi,top,htop,less,vi,vim,ncdu,sh,zsh,bash,fish,git"

    # AI
    @ai      = "Replace_This_With_Your_OpenAI_Key"
    @aimodel = "gpt-4o-mini"

    # LISTS
    @marks       = {}
    @hash        = {}
    @history     = []
    @rubyhistory = []
    @aihistory   = []
  CONFIG
end

def setup_templates # {{{2
  unless File.exist?(PREVIEW_FILE) # {{{3
    File.write PREVIEW_FILE, <<~TEMPLATE
      # ~/.rtfm/preview.rb
      #
      # Define one handler per line in the form:
      #
      #   ext1, ext2, ext3 = command with @s placeholder
      #
      # @s will be replaced by the shell-escaped filename.
      #
      # Lines beginning with # or blank are ignored.
      #
      # Examples:
      #   # plain text, Ruby, Python, shell
      #   txt, rb, py, sh = bat -n --color=always @s
      #
      #   # markdown via pandoc
      #   md = pandoc @s -t plain
      #
      #   # PDFs
      #   pdf = pdftotext -f 1 -l 4 @s -
      #
    TEMPLATE
  end

  unless File.exist?(KEYS_FILE) # {{{3
    File.write KEYS_FILE, <<~TEMPLATE
      # ~/.rtfm/keys.rb
      #
      # Override or add key bindings simply by assigning into KEYMAP
      # and defining the corresponding handler methods.
      #
      # Syntax:
      #   KEYMAP['X'] = :my_handler
      #
      #   def my_handler(chr)
      #     # anything you like—use @pB, @pR, Dir.pwd, etc.
      #     @pB.say("You pressed X!")
      #   end
      #
      # Examples:
      #
      #   # remap 'C' to show config
      #   KEYMAP['C'] = :show_config
      #
      #   # add a new binding: 'Z'
      #   KEYMAP['Z'] = :zap_all
      #   def zap_all(_chr)
      #     @pB.say("ZAPPED!") 
      #   end
    TEMPLATE
  end
end

def display_welcome_message # {{{2
# rubocop:disable Layout/IndentationWidth
@firstrun = "
  Welcome to RTFM - the Ruby Terminal File Manager. This help text is shown on the first run.
  Next time you run RTFM, you can launch it from your terminal with a one letter command: 'r'
  When launched this way, RTFM will also exit in the directory you are currently in.\n".b.fg(226)
@firstrun += "
  To benefit fully from all the features, you need to install some auxiliary software.
  On Ubuntu Linux you would use 'apt install':\n".fg(230)
@firstrun += "
  Basic requirements is 'x11-utils' and 'xdotool':          apt install x11-utils xdotool

  Viewers (you may install more sepcialised viewers later:
  Syntax highlighting of text uses 'bat':                   apt install bat
  Viewing Markdown uses 'pandoc':                           apt install pandoc
  Viewing PDFs uses 'pdftotext':                            apt install poppler-utils
  Viewing LibreOffice docs uses 'odt2txt':                  apt install odt2txt
  Viewing MS docx uses 'docx2txt':                          apt install docx2txt
  Viewing MS pptx uses 'unzip':                             apt install unzip
  Viewing MS xlsx uses 'ssconvert':                         apt install gnumeric
  Viewing MS doc/xls/ppt uses 'catdoc, xls2csv and catppt': apt install catdoc
  Viewing Images uses 'w3m and ImageMagick':                apt install w3m imagemagick
  Viewing Video thumbnails uses 'ffmpegthumbnailer'         apt install ffmpegthumbnailer\n".fg(195)
@firstrun += "
  All of the above in one fell swoop:\n".fg(159)
@firstrun += "
  sudo apt install ruby-full git libncurses-dev x11-utils xdotool bat pandoc poppler-utils odt2txt docx2txt unzip gnumeric catdoc w3m imagemagick ffmpegthumbnailer".b.fg(87)
@firstrun += "\n\n
  You need to install the basic requirements and you should install the viewers before you...
  ... hit any key to start RTFM. Hit ? inside RTFM to show the full help text. Enjoy :-)\n".fg(214)
# rubocop:enable Layout/IndentationWidth
puts @firstrun
end
#checkpoint("Preliminaries done")

# BASIC SETUP {{{1
## Check for installed basic applications {{{2
def cmd?(cmd) # Helper function
  system("which #{cmd} > /dev/null 2>&1")
end

if cmd?('/usr/lib/w3m/w3mimgdisplay')
  @imgdisplay = '/usr/lib/w3m/w3mimgdisplay'
  @showimage = true
else
  @showimage = false
end
@showimage = false unless cmd?('xwininfo') && cmd?('xdotool')

@bat = cmd?('bat') ? 'bat' : 'batcat'

## Set encoding for $stdin to utf-8 {{{2
$stdin.set_encoding(Encoding::UTF_8)

# INITIALIZE VARIABLES {{{1
## These can be set by user in ~/.rtfm/conf
### Saved on quit ('q')
@history     = []      # Initialize the command line history array
@rubyhistory = []      # Initialize the command line history array for ruby commands
@aihistory   = []      # Initialize the command line history array for AI chat
### Saved on Write Config ('W')
@lslong      = ''      # Set short form ls (toggled by pressing "A")
@lsall       = ''      # Set "ls -a" to false (toggled by pressing "a" - sets it to "-a")
@lsorder     = ''      # Change the order/sorting by pressing 'o' (circular toggle)
@lsinvert    = ''      # Set to "-r" to reverse/invert sorting order
@width       = 4       # Set width of the left pane to the default ⅓ of the terminal width
@border      = 1       # Set initial border config; 0 = none, 1 = Right pane, 2 = both panes, 3 = Left pane
@preview     = true    # Preview in the Right pane
@trash       = false   # Delete files permanently rather than moving them to ~/.rtfm/trash
@interactive = 'fzf,navi,top,htop,less,vi,vim,nvim,ncdu,sh,zsh,bash,fish,git,mplayer'
### Not saved (but can be set in ~/.rtfm/conf)
@topcolor    = 249     # Default Top pane bg color
@topmatch    = [['', 249]] # Default Top pane bg color for matching directories
@bottomcolor = 236     # Default Bottom pane color
@searchcolor = 23      # Default color for Search pane at bottom
@cmdcolor    = 18      # Default color for Command pane at bottom
@rubycolor   = 52      # Default color for Ruby pane at bottom
@aicolor     = 58
@lsbase      = '--group-directories-first' # Basic ls setup
@lsuser      = ''      # Set this variable in ~/.rtfm/conf to any 'ls' switch you want to customize directory listings
@batuse      = true    # Use batcat for syntax highlighting
@runmailcap  = false   # Set to 'true' in ~/.rtfm/conf if you want to use run-mailcap instead of xdg-open
@aimodel     = 'gpt-4o-mini' # The default OpenAI model, set another in ~/.rtfm/conf if you like

## These are automatically written to ~/.rtfm/conf upon exit
@marks       = {}      # Initialize (book)marks hash
@hash        = {}      # Initialize the sha directory hashing

## Do not set these in ~/.rtfm/conf
@tagged      = []      # Initialize the tagged array - for collecting all tagged items
@directory   = {}      # Initialize the directory hash for remembering directories visited
@searched    = ''      # Initialize the active searched for items
@lsfiles     = ''      # File types to show (initially set to all file types) - not saved on exit
@lsmatch     = ''      # Files to match (initially set to matching all files) - not saved on exit
@index       = 0       # Set chosen item to first on startup
@tagsize     = 0       # Size (in MB) of tagged items
@navi        = ''      # Navi result when navi is invoked

# LOAD CONFIG {{{1
## Get variables from config file (written back to ~/.rtfm/conf when exit via 'q')
def load_config
  if File.exist?(CONFIG_FILE)
    load(CONFIG_FILE)
    @conf = File.read(CONFIG_FILE).dup
  else
    firstrun
  end
rescue StandardError => e
  errormsg("⚠ Errors while loading #{CONFIG_FILE}\nCheck your config file or delete it to remake in a fresh RTFM start.", e)
end
load_config
@marks['0']  = Dir.pwd # Original dir
@marks["'"]  = Dir.pwd # Initial mark
#checkpoint("Vars/config loaded")

# Handle start dir {{{2
Dir.chdir(ARGV.shift) if ARGV[0] && File.directory?(ARGV[0])

# OPENAI SETUP {{{1
def chat_history # {{{2
  @chat_history ||= [
    { role: 'system',
      content: 'You are a helpful assistant embedded in a terminal file manager. ' \
               'Answer questions about files, directories, or shell commands.' }
  ]
end

def openai_client # {{{2
  require 'ruby/openai' unless defined?(OpenAI)
  @openai_client ||= OpenAI::Client.new(access_token: @ai)
end

# SET UP VIEWER SYSTEM {{{1
# rubocop:disable Style/StringLiterals
preview_specs = {
  'txt, rb, py, sh'    => "#{@bat} -n --color=always @s",
  'md'                 => "pandoc @s -t plain",
  'pdf'                => "pdftotext -f 1 -l 4 @s -",
  'odt, odp, odg, odc' => "odt2txt @s",
  'docx'               => "docx2txt @s -",
  'xlsx'               => "ssconvert -O 'separator=   ' -T Gnumeric_stf:stf_assistant @s fd://1",
  'pptx'               => "unzip -qc @s | ruby -e '$stdin.each_line{ |i| i.force_encoding(\"ISO-8859-1\").scan(/<a:t>(.+?)<\\/a:t>/).each{ |j| puts j } }'",
  'doc'                => "catdoc @s 2>/dev/null",
  'xls'                => "xls2csv @s 2>/dev/null",
  'ppt'                => "catppt @s 2>/dev/null",
  # images ⇒ nil => call showimage
  'png, jpg, jpeg, bmp, gif, webp, tif, tiff' => nil,
  # video ⇒ nil, but detected via pattern below
  'mpg, mpeg, avi, mov, mkv, mp4'             => nil
}
@imagefile ||= /\.(?:png|jpe?g|bmp|gif|webp|tiff?)$/i
@pdffile   ||= /\.pdf$/i
# rubocop:enable Style/StringLiterals

# USER PLUGINS {{{1
# Merge in any user overrides from ~/.rtfm/preview.rb
if File.exist?(PREVIEW_FILE)
  begin
    File.readlines(PREVIEW_FILE).each_with_index do |line, idx|
      line = line.strip
      next if line.empty? || line.start_with?('#')

      if line =~ /\A([0-9A-Za-z_,\s]+)\s*=\s*(.+)\z/
        exts_str = $1.strip
        cmd_str  = $2.strip
        preview_specs[exts_str] = cmd_str
      else
        @plugin_errors << "Invalid preview.rb line #{idx + 1}: #{line}"
      end
    end
  rescue => e
    @plugin_errors << "Error loading preview.rb: #{e.class}: #{e.message}"
  end
end
# Compile into an array of [Regexp, template] for fast lookup
PREVIEW_HANDLERS = preview_specs.map do |exts_str, tmpl|
  exts = exts_str.split(',').map(&:strip).map { |ext| Regexp.escape(ext) }.join('|')
  [/\.#{exts}$/i, tmpl]
end
#checkpoint("Plugins loaded")

# KEY DISPATCH TABLE & HANDLERS {{{1
KEYMAP = { # {{{2
  # BASIC KEYS {{{3
  '?'       => :show_help,
  'v'       => :show_version,
  'r'       => :refresh_all,
  'R'       => :load_config,
  'C'       => :show_config,
  'W'       => :write_config,
  'q'       => :quit_and_save,
  'Q'       => :quit_no_save,

  # LAYOUT {{{3
  'w'       => :change_width,
  'B'       => :toggle_border,
  '-'       => :toggle_preview,
  '_'       => :toggle_image,
  'b'       => :toggle_syntax,

  # MOTION {{{3
  'DOWN'    => :move_down,
  'j'       => :move_down,
  'C-DOWN'  => :move_down,
  'UP'      => :move_up,
  'k'       => :move_up,
  'C-UP'    => :move_up,
  'LEFT'    => :move_left,
  'h'       => :move_left,
  'C-LEFT'  => :move_left,
  'RIGHT'   => :move_right,
  'l'       => :move_right,
  'C-RIGHT' => :move_right,
  'x'       => :open_force,
  'PgDOWN'  => :page_down,
  'PgUP'    => :page_up,
  'END'     => :go_last,
  'HOME'    => :go_first,

  # MARKS & JUMPING {{{3
  'm'       => :set_mark,
  'M'       => :show_marks,
  "'"       => :jump_to_mark,
  '~'       => :go_home,
  '>'       => :follow_symlink,

  # DIRECTORY VIEWS {{{3
  'a'       => :toggle_all,
  'A'       => :toggle_long,
  'o'       => :toggle_order,
  'i'       => :toggle_invert,
  'O'       => :show_ls_command,

  # TAGGING {{{3
  't'       => :tag_current,
  'C-T'     => :tag_pattern,
  'T'       => :show_tagged,
  'u'       => :clear_tagged,

  # MANIPULATE ITEMS {{{3
  'p'       => :copy_items,
  'P'       => :move_items,
  'c'       => :rename_item,
  's'       => :link_items,
  'd'       => :delete_items,
  'D'       => :empty_trash,
  'C-D'     => :toggle_trash,
  'C-O'     => :change_ownership,
  'C-P'     => :change_permissions,

  # FILTER AND SEARCH {{{3
  'f'       => :filter_types,
  'F'       => :filter_regex,
  'C-F'     => :filter_clear,
  '/'       => :search_text,
  '\\'      => :clear_search,
  'n'       => :search_next,
  'N'       => :search_prev,
  'g'       => :grep_current,
  'L'       => :locate,
  '#'       => :jump_locate,
  'C-L'     => :fzf_jump,

  # ARCHIVES {{{3
  'z'       => :unzip_items,
  'Z'       => :zip_items,

  # GIT/HASH/OPENAI {{{3
  'G'       => :git_status,
  'H'       => :hash_directory,
  'I'       => :openai_description,
  'C-A'     => :chat_mode,

  # RIGHT PANE CONTROLS {{{3
  'ENTER'   => :refresh_right,
  'S-DOWN'  => :line_down_right,
  'S-UP'    => :line_up_right,
  'S-RIGHT' => :page_down_right,
  'TAB'     => :page_down_right,
  'S-LEFT'  => :page_up_right,
  'S-TAB'   => :page_up_right,

  # CLIPBOARD COPY {{{3
  'y'       => :copy_path,
  'Y'       => :copy_path,
  'C-Y'     => :copy_right,

  # SYSTEM SHORTCUTS {{{3
  'S'       => :system_info,
  '='       => :make_directory,
  'C-N'     => :navi_invoke,

  # COMMAND MODE {{{3
  ':'       => :command_mode,
  ';'       => :show_history,
  '+'       => :add_interactive,

  # RUBY MODE {{{3
  '@'       => :ruby_debug
}

# USER KEYS (override or extend KEYMAP) {{{2
if File.exist?(KEYS_FILE)
  begin
    load KEYS_FILE
  rescue => e
    @plugin_errors << "Error loading keys.rb: #{e.class}: #{e.message}"
  end
end

# MAIN GETKEY FOR USER INPUT {{{2
def getkey # {{{3
  chr = getchr(1)
  return unless chr

  showimage('clear') if @image
  @image = false
  if handler = KEYMAP[chr]  # rubocop:disable Lint/AssignmentInCondition
    m = method(handler)
    m.arity == 1 ? m.call(chr) : m.call
  end
rescue Errno::EIO
  # ignore transient TTY/read errors when upon focus switch
  return
rescue StandardError => e
  errormsg('⚷ Error in getkey', e)
end

# BASIC KEYS {{{2
def show_help # {{{3
  @pR.say(@help.fg(249))
end

def show_version # {{{3
  @pB.say(" RTFM version = #{@version} (latest RubyGems version is #{Gem.latest_version_for('rtfm-filemanager').version} - https://github.com/isene/RTFM)".b)
end

def refresh_all # {{{3
  refresh
end

def show_config
  @pR.say('Configuration'.u.fg(254) + ":\n\n" + @conf.fg(249))
end

def write_config # {{{3
  conf_write(all: true)
  show_config
end

def quit_and_save # {{{3
  shell("printf \"\e]0;#{Dir.pwd}\007\"")
  conf_write
  exit_rtfm
end

def quit_no_save # {{{3
  shell("printf \"\e]0;#{Dir.pwd}\007\"")
  exit_rtfm
end

# LAYOUT {{{2
def change_width # {{{3
  @width += 1
  @width = 2 if @width == 8
  refresh
  @pR.update = @pB.update = true
end

def toggle_border # {{{3
  @border = (@border + 1) % 4
  setborder
end

def toggle_preview # {{{3
  @preview = !@preview
  @pB.say("Preview = #{@preview ? 'On' : 'Off'}")
  @pR.clear unless @preview
end

def toggle_image # {{{3
  @showimage = !@showimage
  @pB.say("Image preview = #{@showimage ? 'On' : 'Off'}")
  getch
end

def toggle_syntax # {{{3
  @batuse = !@batuse
  @pB.say("Syntax highlighting = #{@batuse ? 'On' : 'Off'}")
  @pR.update = true
end

# MOTION {{{2
def move_down # {{{3
  @index = @index >= @max_index ? @min_index : @index + 1
  @pR.update = @pB.update = true
end

def move_up # {{{3
  @index = @index <= @min_index ? @max_index : @index - 1
  @pR.update = @pB.update = true
end

def move_left # {{{3
  old_dir = Dir.pwd
  parent  = File.dirname(old_dir)
  child   = File.basename(old_dir)
  purels = command(
    "ls #{Shellwords.escape(parent)} #{@lsbase} #{@lsall} #{@lsorder} #{@lsinvert} #{@lsuser}"
  ).pure.split("\n")
  child_idx = purels.index(child) || 0
  @directory[parent] = child_idx
  mark_latest
  Dir.chdir(parent)
  @pL.update = @pR.update = @pB.update = true
end

def move_right # {{{3
  @directory[Dir.pwd] = @index
  mark_latest
  open_selected
  @index = @directory[Dir.pwd] || 0
  @pB.update = true
end

def open_force # {{{3
  @directory[Dir.pwd] = @index
  mark_latest
  open_selected(true)
  @pB.update = true
end

def page_down # {{{3
  @index += @pL.h - 2
  @index = @max_index if @index > @max_index
  @pR.update = @pB.update = true
end

def page_up # {{{3
  @index -= @pL.h - 2
  @index = @min_index if @index < @min_index
  @pR.update = @pB.update = true
end

def go_last # {{{3
  @index = @max_index
  @pR.update = @pB.update = true
end

def go_first # {{{3
  @index = @min_index
  @pR.update = @pB.update = true
end

# MARKS & JUMPING {{{2
def set_mark # {{{3
  marks_info
  @pB.say("Set mark by pressing any letter. Delete mark by pressing '-' and the letter of the mark to remove.".fg(156))
  m = getchr
  return if m == 'ESC'

  if m =~ /[\w']/
    @marks[m] = Dir.pwd
  elsif m == '-'
    @pB.say('Press the letter of the mark to remove.'.fg(156))
    r = getchr; @marks.delete(r)
  end
  marks_info
  @pB.update = true
end

def show_marks # {{{3
  marks_info
  @pB.update = true
end

def jump_to_mark # {{{3
  marks_info
  m = getchr
  if m =~ /[\w']/ && @marks[m]
    @directory[Dir.pwd] = @index
    dir_before = Dir.pwd
    begin; Dir.chdir(@marks[m]); rescue; @pB.say(' No such directory'); end
    mark_latest
    @marks["'"] = dir_before
  end
  @pR.update = @pB.update = true
end

def go_home # {{{3
  @directory[Dir.pwd] = @index
  mark_latest
  Dir.chdir
  @pR.update = @pB.update = true
end

def follow_symlink # {{{3
  @directory[Dir.pwd] = @index; mark_latest
  if File.symlink?(@selected)
    begin
      target = File.readlink(@selected)
      target = File.expand_path(target, File.dirname(@selected)) unless target.start_with?('/')
      Dir.chdir(target)
    rescue => e
      @pB.say("Error following symlink: #{e}")
    end
  end
  @pB.update = true
end

# DIRECTORY VIEWS {{{2
def toggle_all # {{{3
  @lsall = @lsall.empty? ? '-a' : ''
  @pR.update = @pB.update = true
end

def toggle_long # {{{3
  @lslong = @lslong.empty? ? '-lh --time-style=long-iso' : ''
  @pR.update = @pB.update = true
end

def toggle_order # {{{3
  case @lsorder
  when ''
    @lsorder = '-S'; @pB.say(' Sorting by size')
  when '-S'
    @lsorder = '-t'; @pB.say(' Sorting by time')
  when '-t'
    @lsorder = '-X'; @pB.say(' Sorting by extension')
  else
    @lsorder = '';  @pB.say(' Normal sorting')
  end
  @pR.update = true; @orderchange = true
end

def toggle_invert # {{{3
  @lsinvert = @lsinvert.empty? ? '-r' : ''
  @pB.say(' Sorting inverted')
  @pR.update = true; @orderchange = true
end

def show_ls_command # {{{3
  @pB.say(" Full 'ls' command: ls #{@lsbase} #{@lslong} #{@lsall} #{@lsorder} #{@lsinvert} #{@lsuser}".gsub(/ +/, ' '))
  @pB.update = false
end

# TAGGING {{{2
def tag_current # {{{3
  item = @selected
  if @tagged.include?(item)
    @tagged.delete(item); @tagsize -= File.size(item) rescue 0
  else
    @tagged.push(item); @tagsize += File.size(item) rescue 0
  end
  @index = [@index + 1, (@files.size - 1)].min
  @pB.say(" Tagged #{@tagged.size} files (#{(@tagsize.to_f / 1_000_000).round(2)}MB)".fg(204))
  @pB.update = false; @pR.update = true; @pL.update = true
end

def tag_pattern # {{{3
  pat = @pB.ask('Tag pattern (ruby regex): ', '')
  re  = Regexp.new(pat)
  matches = @files.grep(re).map { |t| File.join(Dir.pwd, t) }
  matches.each do |f|
    @tagsize += File.size(f) rescue nil
  end
  @tagged.concat(matches)
  @tagged.uniq!
  @pB.say(" Tagged #{@tagged.size} files (#{(@tagsize.to_f / 1_000_000).round(2)}MB)".fg(204))
  @pB.update = false
  @pR.update = true
end

def show_tagged # {{{3
  tagged_info
  @pB.update = true
end

def clear_tagged # {{{3
  @tagged = []
  tagged_info
  @pB.update = true
end

# MANIPULATE ITEMS {{{2
def copy_items # {{{3
  copy_move_link('copy')
  @pR.update = true
end

def move_items # {{{3
  copy_move_link('move')
  @pR.update = true
end

def rename_item # {{{3
  basename = File.basename(@selected)
  dir      = File.dirname(@selected)
  display  = basename.length > 12 ? basename[0, 12] + '…' : basename
  tpl      = "mv \"#{display}\" \"#{basename}\""
  cmd      = @pCmd.ask(': ', tpl).pure
  match        = cmd.match(/mv\s+"[^"]+"\s+"([^"]+)"/)
  new_basename = match ? match[1] : basename
  old_esc      = Shellwords.escape(@selected)
  new_path     = File.join(dir, new_basename)
  new_esc      = Shellwords.escape(new_path)
  shellexec("mv #{old_esc} #{new_esc}")
  dirlist
  # point @selected and @index at the new name
  @selected = new_path
  new_idx   = @files.index(new_basename)
  @index    = new_idx if new_idx
  render
end

def link_items # {{{3
  copy_move_link('link')
  @pR.update = true
end

def delete_items # {{{3
  tagged_info
  @pR.text << "\n\n Selected:\n\n #{@selected}".fg(204).b
  @pR.refresh
  # choose wording based on @trash
  action      = @trash ? 'Move (to ~/.rtfm/trash)' : 'Delete'
  past_action = @trash ? 'Moved'                   : 'Deleted'
  @pB.say(" #{action} selected and tagged? (press 'y')")
  if getchr == 'y'
    # collect & escape every path
    paths = (@tagged + [@selected]).uniq
    esc   = paths.map { |p| Shellwords.escape(p) }.join(' ')
    if @trash
      esc_trash = Shellwords.escape(TRASH_DIR)
      command("mv -f #{esc} #{esc_trash}")
    else
      command("rm -rf #{esc}")
    end
    @tagged.clear
    refresh_right
    @pR.say("#{past_action} #{paths.size} items#{@trash ? " to #{TRASH_DIR}" : ''}".fg(204))
  else
    @pB.update = true
  end
end

def empty_trash # {{{3
  @pB.say(" Really empty Trash (~/.rtfm/trash)? (press 'y')")
  return unless  getchr == 'y'

  command("rm -rf #{TRASH_DIR}/*")
  @pB.say('Trash is now empty')
  render
end

def toggle_trash # {{{3
  @trash = !@trash
  @pB.say("Trash (~/.rtfm/trash) = #{@trash ? 'On' : 'Off'}")
end

def change_ownership # {{{3
  require 'etc'
  gnm = Etc.getgrgid(File.stat(@selected).gid).name
  unm = Etc.getpwuid(File.stat(@selected).uid).name
  ans = @pB.ask('Change ownership (user:group): ', "#{unm}:#{gnm}")
  user, group = ans.split(':')
  uid = Etc.getpwnam(user).uid
  gid = Etc.getgrnam(group).gid
  File.chown(uid, gid, @selected)
  @tagged.each { |t| File.chown(uid, gid, t) rescue nil }
  if user == unm && group == gnm
    @pB.say('No change in ownership')
  else
    @pB.say("Ownership changed to #{user}:#{group}")
  end
end

def change_permissions # {{{3
  # strip leading “-” off e.g. "-rwxr-xr-x" → "rwxr-xr-x"
  default = @fileattr.split[1][1..]
  ans = @pB.ask('Permissions: ', default)
  mode = if ans =~ /^\d{3}$/          # "755"
           ans.to_i(8)
         elsif ans.length == 3           # "rwx" → "rwxrwxrwx"
           # compute the single octal digit
           digit = ans.chars.map do |c|
             (c == 'r' ? 4 : 0) +
             (c == 'w' ? 2 : 0) +
             (c == 'x' ? 1 : 0)
           end.sum
           # replicate for user, group, other
           (digit * 64) + (digit * 8) + digit
         elsif ans.length == 9           # "rwxr-xr-x"
           # split into three triads and compute each
           triads = ans.scan(/.{3}/)
           perms  = triads.map do |tri|
             (tri[0] == 'r' ? 4 : 0) +
             (tri[1] == 'w' ? 2 : 0) +
             (tri[2] == 'x' ? 1 : 0)
           end
           (perms[0] * 64) + (perms[1] * 8) + perms[2]
         end
  if mode.nil?
    @pB.say('Invalid mode')
  else
    current = File.stat(@selected).mode & 0o777
    if mode == current
      @pB.say("No change needed (already #{mode.to_s(8)})")
    else
      File.chmod(mode, @selected)
      @tagged.each { |t| File.chmod(mode, t) rescue nil }
      @pB.say("Permissions changed to: #{mode.to_s(8)}")
    end
  end
end

# FILTER AND SEARCH {{{2
def filter_types # {{{3
  @lsfiles = @pB.ask('Filetype(s) to show: ', @lsfiles)
  @pR.update = @pB.update = true
end

def filter_regex # {{{3
  @lsmatch = @pB.ask('Files match RegEx: ', @lsmatch)
  @pB.say(nil)
  @pR.update = @pB.update = true
end

def filter_clear # {{{3
  @lsfiles = @lsmatch = ''
  @pB.say('All filtering cleared.')
end

def search_text # {{{3
  @searched = @pSearch.ask('/ ', '')
  l = command("ls #{@lsbase} #{@lsall} #{@lsorder} #{@lsinvert} #{@lsuser}").split
  m = l.each_index.select { |n| l[n] =~ /#{@searched}/ }
  @index = m.first unless m.empty?
  @index = 0 if @searched.empty?
  @pR.update = true; @pB.full_refresh
end

def clear_search # {{{3
  @searched = ''
end

def search_next # {{{3
  l = command("ls #{@lsbase} #{@lsall} #{@lsorder} #{@lsinvert} #{@lsuser}").split
  m = l.each_index.select { |n| l[n] =~ /#{@searched}/ }
  i = m.find { |n| n > @index }
  @index = i || m.first
  @pR.update = true
end

def search_prev # {{{3
  l = command("ls #{@lsbase} #{@lsall} #{@lsorder} #{@lsinvert} #{@lsuser}").split
  m = l.each_index.select { |n| l[n] =~ /#{@searched}/ }.reverse
  i = m.find { |n| n < @index }
  @index = i || m.first
  @pR.update = true
end

def grep_current # {{{3
  cmd = @pCmd.ask(': ', 'grep -s MATCH *')
  shellexec(cmd)
end

def locate # {{{3
  cmd = @pCmd.ask(': ', 'locate ')
  cmd += " | #{@bat} -n --color=always"
  shellexec(cmd)
  @locate = true
end

def jump_locate # {{{3
  @pB.update = true; return unless @locate

  nr = @pB.ask('# ', '').to_i
  line = @pR.text.lines[nr - 1]
  unless line
    @pB.say('Error: No such file or directory.'); @pB.update = false; return
  end
  jump = line.pure[%r{/\S+}]
  dir = File.dirname(jump); tgt = File.basename(jump)
  @directory[Dir.pwd] = @index; mark_latest; Dir.chdir(dir); @dir_old = Dir.pwd
  l = command("ls #{@lsbase} #{@lsall} #{@lsorder} #{@lsinvert} #{@lsuser}").split("\n")
  @index = l.index { |t| t == tgt }
end

def fzf_jump # {{{ 3
  unless system('which fzf > /dev/null 2>&1')
    @pB.say(' fzf not installed – see https://github.com/junegunn/fzf')
    return
  end
  # 2) Prepare a temp file for the single-line selection
  tmp = File.join(Dir.tmpdir, 'rtfm_fzf_selection')
  # Launch fzf:
  #  - stdin  <- /dev/tty so fzf reads from terminal
  #  - stdout -> tmp to capture only the chosen entry
  #  - stderr -> /dev/tty so fzf can draw its full-screen UI
  system("fzf < /dev/tty > #{Shellwords.escape(tmp)} 2> /dev/tty")
  jump = File.exist?(tmp) ? File.read(tmp).chomp : ''
  File.delete(tmp)
  return if jump.empty?

  dir = File.dirname(jump)
  tgt = File.basename(jump)
  @directory[Dir.pwd] = @index
  mark_latest
  Dir.chdir(dir)
  @dir_old = Dir.pwd
  l = command("ls #{@lsbase} #{@lsall} #{@lsorder} #{@lsinvert} #{@lsuser}").split("\n")
  @index = l.index { |t| t == tgt } || 0
  @pL.update = @pR.update = @pB.update = true
end

# ARCHIVES {{{2
def unzip_items # {{{3
  first = @tagged.first
  tar   = Shellwords.escape(first)
  cmd   = @pCmd.ask('Command: ', "tar xfz #{tar}")
  shellexec(cmd)
  render
end

def zip_items # {{{3
  arc = @pCmd.ask('Archive name: ', '')
  # escape archive base and all paths
  arc_esc    = Shellwords.escape(arc)
  tagged_esc = @tagged.map { |p| Shellwords.escape(p) }.join(' ')
  cmd        = @pCmd.ask('Command: ', "tar cfz #{arc_esc}.gz #{tagged_esc}")
  shellexec(cmd + ' 2>/dev/null')
  render
end

# GIT/HASH/OPENAI {{{2
def git_status # {{{3
  @pR.clear
  out, err   = command('git status', return_both: true)
  @pR.text  += err.fg(196) unless err.empty?
  @pR.text  += out.fg(214) unless out.empty?
  @pR.full_refresh
  @pR.update = false
  @pB.update = true
end

def hash_directory # {{{3
  dir = Shellwords.escape(Dir.pwd)
  @pB.say("Creating hash for #{dir}. May take a while…")
  hashcmd = <<~CMD.chomp
    (find #{dir} -type f -print0 |
      sort -z |
      xargs -0 sha1sum;
    find #{dir} \\( -type f -o -type d \\) -print0 |
      sort -z |
      xargs -0 stat -c '%n %a') |
    sha1sum |
    cut -c -40
  CMD
  hashdir = command(hashcmd, timeout: 300).chomp
  hashtime = DateTime.now.strftime('%Y-%m-%d %H:%M')
  if @hash.key?(Dir.pwd)
    old_time, old_hash = @hash[Dir.pwd]
    if old_hash == hashdir
      @pB.say(" Hash for #{Dir.pwd} has NOT changed since #{old_time} (#{hashdir})".fg(213))
    else
      @pB.say(" Hash for #{Dir.pwd} has CHANGED: #{old_time}→#{hashtime} (#{old_hash}→#{hashdir})".fg(213))
      @hash[Dir.pwd] = [hashtime, hashdir]
    end
  else
    @hash[Dir.pwd] = [hashtime, hashdir]
    @pB.say(" New hash for #{Dir.pwd}: #{hashtime}: #{hashdir}".fg(213))
  end
  @pR.update = true
end

def openai_description # {{{3
  begin
    require 'ruby/openai'
  rescue LoadError
    @pB.say('To enable AI-descriptions: `gem install ruby-openai` and set @ai in ~/.rtfm/conf')
    return
  end
  unless @ai && !@ai.empty?
    @pB.say("Set your API key in ~/.rtfm/conf: @ai = 'your-secret-openai-key'")
    return
  end
  # Context
  path    = File.join(Dir.pwd, @selected.to_s)
  is_dir  = File.directory?(path)
  preview = @pR.text.pure.strip
  # Enhanced prompt
  parts = []
  parts << 'You are an expert terminal file manager assistant.'
  parts << (is_dir ?  "Summarize the overall purpose and contents of this directory: #{path}." : "Summarize the purpose of this file: #{path}.")
  parts << 'Since this is source code, do a brief code review: highlight bugs, style issues, and improvements.' if !is_dir && path.match?(/\.(sh|rb|py|js|go|java|41)$/i)
  parts << 'Embedded Documentation Lookup: for any libraries, commands, or APIs used, include a one-sentence summary from their official docs.'
  parts << "Git-Aware Diff Explanation: summarize the most recent `git diff` touching #{path}, explaining what changed." if Dir.exist?(File.join(Dir.pwd, '.git'))
  parts << "Existing preview text: #{preview}" unless preview.empty?
  prompt = parts.join(' ')
  # Send to OpenAI
  client = OpenAI::Client.new(access_token: @ai)
  @pR.say('Thinking...'.fg(244))
  response = client.chat(
    parameters: {
      model:      @aimodel,
      messages:   [{ role: 'user', content: prompt }],
      max_tokens: 600
    }
  ) rescue nil
  answer = response&.dig('choices', 0, 'message', 'content') ||
           '⚠️ Error or empty response from OpenAI.'
  @pR.say(answer.fg(230))
end

def chat_mode # {{{3
  unless defined?(OpenAI) && @ai && !@ai.empty?
    @pB.say("To make OpenAI work in RTFM, run `gem install ruby-openai` and add to ~/.rtfm/conf:\n  @ai = 'your-secret-openai-key'")
    return
  end

  @pB.clear; @pB.update = true
  question = @pAI.ask('Chat> ', '').strip
  return if question.empty?

  chat_history << { role: 'user', content: question }
  @pR.say('Thinking...'.fg(230))
  reply = openai_client.chat(
    parameters: {
      model:    @aimodel,
      messages: chat_history,
      max_tokens: 400
    }
  ) rescue nil
  answer = reply&.dig('choices', 0, 'message', 'content') ||
           '⚠️ API error or empty response'
  chat_history << { role: 'assistant', content: answer }
  @pR.say(answer.fg(230))
  @pB.clear; @pB.update = true
end

# RIGHT PANE CONTROLS {{{2
def refresh_right # {{{3
  render
  @pR.full_refresh
  @pR.update = @pB.update = true
end

def line_down_right # {{{3
  @pR.linedown; @pB.update = true
end

def line_up_right # {{{3
  @pR.lineup;   @pB.update = true
end

def page_down_right # {{{3
  @pR.pagedown; @pB.update = true
end

def page_up_right # {{{3
  @pR.pageup; @pB.update = true
end

# CLIPBOARD COPY {{{2
def copy_path # {{{3
  if @selected
    clip = "xclip -selection #{getchr == 'Y' ? 'clipboard' : 'primary'} -in -loops 1"
    @pB.say(' Path copied')
    shell("echo -n '#{@selected}' | #{clip}")
  else
    @pB.say(' No selected item path to copy')
  end
end

def copy_right # {{{3
  clip = 'xclip -selection clipboard'
  @pB.say(' Right pane copied to clipboard')
  # We drop the trailing & in the string itself…
  shell("echo -n #{Shellwords.escape(@pR.text.pure)} | #{clip} > /dev/null 2>&1", background: true)
end

# SYSTEM SHORTCUTS {{{2
def system_info # {{{3
  text = ''
  begin
    uname    = `uname -o`.chomp + '  '
    uname   += `uname -r`.chomp + '  '
    uname   += `uname -v`.chomp + '  '
    uname   += `uname -p`.chomp + '  '
    uname   += `awk -F '"' '/PRETTY/ {print $2}' /etc/os-release` + "\n"
    text    += uname.b.fg(253)
    host     = `hostnamectl`
    chost    = host.lines.map do |line|
      if line.include?(':')
        before, after = line.split(':', 2)
        "#{(before + ':').fg(253)}#{after.fg(111)}"
      else
        line
      end
    end.join
    text    += chost + "\n"
  rescue # rubocop:disable Lint/SuppressedException
  end
  begin
    system   = 'Shell & Terminal: ' + `echo $SHELL`.sub(%r{.*/}, '').chomp + ', ' + `echo $TERM`.chomp + '   '
    packages = `pacman -Q 2>/dev/null | wc -l`.chomp
    packages = `dpkg-query -l 2>/dev/null | grep -c '^.i'`.chomp if packages == '0'
    packages = 'Unrecognized' if packages == '0'
    cpu      = 'CPUs = ' + `nproc`.chop + '  '
    cpuinfo  = `lscpu`
    cpu     += cpuinfo[/^.*Model name:\s*(.*)/, 1] + '  '
    cpu     += 'Max: ' + cpuinfo[/^.*CPU max MHz:\s*(.*)/, 1].to_i.to_s + 'MHz  '
    cpu     += 'Min: ' + cpuinfo[/^.*CPU min MHz:\s*(.*)/, 1].to_i.to_s + "MHz\n\n"
    text    += cpu.fg(154)
    system  += 'Packages: ' + packages + "\n"
    system  += 'Desktop: ' + `awk '/^DesktopNames/' /usr/share/xsessions/* | sed 's/DesktopNames=//g' | \\
                sed 's/\\;/\\n/g' | sed '/^$/d' | sort -u | sed ':a;N;$!ba;s/\\n/, /g'`.chomp + '/'
    system  += `grep 'gtk-theme-name' ~/.config/gtk-3.0/* | sed 's/gtk-theme-name=//g' | \\
                sed 's/-/ /g'`.sub(/.*:/, '') + "\n"
    text    += system.fg(251)
  rescue # rubocop:disable Lint/SuppressedException
  end
  begin
    mem      = `free -h` + "\n"
    text    += mem.fg(229)
  rescue # rubocop:disable Lint/SuppressedException
  end
  begin
    ps       = `ps -eo comm,pid,user,pcpu,pmem,stat --sort -pcpu,-pmem | head` + "\n"
    text    += ps.fg(195)
  rescue # rubocop:disable Lint/SuppressedException
  end
  begin
    disk     = `df -H | head -8`
    text    += disk.fg(172)
  rescue # rubocop:disable Lint/SuppressedException
  end
  begin
    dmesg  = "\nDMESG (latest first):\n"
    dcmd   = `dmesg 2>/dev/null | tail -6`.split("\n").sort.reverse.join("\n")
    dmesg += dcmd == '' ? "dmesg requires root, run 'sudo sysctl kernel.dmesg_restrict=0' if you need permission\n" : dcmd
    text  += dmesg.fg(219)
  rescue # rubocop:disable Lint/SuppressedException
  end
  @pR.say(text)
rescue
  @pR.say('Unable to show system info')
end

def make_directory # {{{3
  cmd = @pCmd.ask(': ', 'mkdir ')
  shellexec(cmd + ' -p')
end

def navi_invoke # {{{3
  @navi = `navi`
rescue
  @pB.say(' navi not installed - see https://github.com/junegunn/fzf')
end

# COMMAND MODE {{{2
def command_mode # {{{3
  raw = @pCmd.ask('Shell command: ', '').strip
  @pB.clear; @pB.update = true
  return if raw.empty?

  # Prefix override: §cmd = force interactive
  force = raw.start_with?('§')
  raw = raw[1..].strip if force
  # Expand @s / @t
  sel = Shellwords.escape(@selected.to_s)
  tg  = @tagged.map { |p| Shellwords.escape(p) }.join(' ')
  cmd = raw.gsub('@s', sel).gsub('@t', tg)
  # Determine program name
  prog = Shellwords.split(cmd).first
  prog = File.basename(prog) if prog
  # Whitelist check against @interactive
  inter_list = (@interactive || '').split(',').map(&:strip)
  whitelist = prog && inter_list.include?(prog)
  # Magic PTY-peek (only if not forced or whitelisted)
  magic = false
  unless force || whitelist
    begin
      PTY.spawn(cmd) do |r, _w, pid|
        begin
          Timeout.timeout(0.1) do
            magic = r.readpartial(1024).include?("\e[?1049h")
          end
        rescue Timeout::Error
          # no quick data = assume non-TUI
        ensure
          Process.kill('TERM', pid) rescue nil
          Process.wait(pid)        rescue nil
        end
      end
    rescue Errno::ENOENT, Errno::EIO
      # command not found or PTY closed immediately = non-TUI
    end
  end
  if force || whitelist || magic # Decide interactive vs non-interactive
    # Restore shell tty so Ctrl-C/D work
    system("stty #{ORIG_STTY} < /dev/tty")
    # Clear to top-left
    system('clear < /dev/tty > /dev/tty')
    Cursor.show
    # Spawn on real tty
    pid2 = Process.spawn(cmd,
                         in:  '/dev/tty',
                         out: '/dev/tty',
                         err: '/dev/tty')
    begin
      Process.wait(pid2)
    rescue Interrupt
      Process.kill('TERM', pid2) rescue nil
      retry
    end
    # Restore raw/no-echo for RTFM
    system('stty raw -echo isig < /dev/tty')
    $stdin.raw!
    $stdin.echo = false
    Cursor.hide
    Rcurses.clear_screen
    refresh
    render
  else
    shellexec(cmd)
    @pR.refresh
    @pR.update = false
  end
end

def show_history # {{{3
  @pR.say("Command history:\n\n" + @pCmd.history.reverse.join("\n"))
  @pB.update = true
end

def add_interactive # {{{
  @interactive = @pB.ask('Add program to @interactive: '.fg(213), @interactive.fg(213))
  @pB.clear; @pB.update = true
end

# RUBY MODE {{{2
def ruby_debug # {{{3
  require 'stringio'
  cmd = @pRuby.ask('Ruby command: ', '')
  @pR.text = "Command: #{cmd}\n\n".fg(205)
  original_stdout = $stdout
  original_stderr = $stderr
  stdout_captured = StringIO.new
  stderr_captured = StringIO.new
  $stdout = stdout_captured
  $stderr = stderr_captured
  begin
    eval(cmd) # rubocop:disable Security/Eval
  rescue Exception => e # rubocop:disable Lint/RescueException
    puts "Error: #{e.message}\n#{e.backtrace.join("\n")}"
  ensure
    $stdout = original_stdout
    $stderr = original_stderr
  end
  @pR.text += stdout_captured.string + "\n\n" + stderr_captured.string
  @pR.refresh
  @pR.update = false
  @pB.full_refresh
end

# GENERIC FUNCTIONS {{{1
def dirlist(left: true) # LIST DIRECTORIES {{{2
  @index ||= 0
  @index = @index.to_i
  if left
    dir   = Dir.pwd
    width = @pL.w
  else
    dir = if @selected && File.directory?(@selected)
            File.symlink?(@selected) ? File.realpath(@selected) : @selected.to_s
          else
            File.dirname(@selected)
          end
    width = @pR.w
  end
  # Fetch plain names + colored lines
  purels  = command("ls #{Shellwords.escape(dir)} #{@lsbase} #{@lsall} #{@lsorder} #{@lsinvert} #{@lsuser}").pure.split("\n")
  colorls = command("ls --color #{Shellwords.escape(dir)} #{@lsbase} #{@lsall} #{@lslong} #{@lsorder} #{@lsinvert} #{@lsuser}").split("\n")
  colorls.shift if colorls[0]&.strip == "#{dir}:"
  colorls.shift if colorls[0]&.match?(/^total/)
  if left && @orderchange # Keep the same @selected even when we re-sort
    basename = File.basename(@selected.to_s)
    new_idx  = purels.index(basename)
    @index   = new_idx if new_idx
    @orderchange = false
  end
  entries = purels.zip(colorls) # Zip into pairs and filter
  unless @lsfiles.empty?  # filter by extension(s)
    exts = @lsfiles.split(',').map { |e| /\.#{Regexp.escape(e)}$/i }
    entries.select! { |name, _| exts.any? { |re| name =~ re } }
  end
  unless @lsmatch.empty?  # filter by regex
    re = Regexp.new(@lsmatch)
    entries.select! { |name, _| name =~ re }
  end
  # Unzip, with safe defaults if nothing matched
  t = entries.transpose
  purels = t[0] || []
  ls     = t[1] || []
  @files = purels if left
  # Update @selected & @fileattr for left pane
  if left && purels[@index]
    @selected = Dir.pwd + '/' + purels[@index]
    sfile = @selected.dup
    sfile += '/' if File.directory?(@selected)
    slsl_cmd = "ls -ldHlh --time-style=long-iso #{Shellwords.escape(sfile)}"
    slsl = command(slsl_cmd)
    a = slsl.split
    @fileattr = a.size >= 7 ? "#{a[2]}:#{a[3]} #{a[0]}  #{a[4]}  #{a[5]} #{a[6]}" : ''
  end
  # Map & decorate each colored line
  ls.map!.with_index do |el, i|
    n = el.to_s.clean_ansi
    n = n.shorten(width - 5).inject('…', -1) if n.pure.length > width - 6
    raw_name = (purels[i] || '').strip
    base     = left ? Dir.pwd : dir
    fullpath = "#{base}/#{raw_name}"
    n = n.inject('@', -1) if File.symlink?(fullpath)
    n = n.inject('/', -1) if File.directory?(fullpath)
    n = n.bg(238) if !raw_name.empty? && raw_name.match(/#{@searched}/) && @searched != ''
    n = n.r if @tagged.include?(fullpath)
    if left
      n = (i == @index ? '→ ' + n.u : '  ' + n)
    end
    n
  end
  ls.join("\n")
end

def render # RENDER ALL PANES {{{2
  # LEFT pane {{{3
  if @pL.update
    lefttext = @pL.text
    @pL.text = dirlist
    scrolloff = 3
    total     = @files.size
    page      = @pL.h
    if total <= page
      # If everything fits, always start from the very top
      @pL.ix = 0
    elsif @index - @pL.ix < scrolloff
      # If we're too close to the top of the pane, scroll up
      @pL.ix = [@index - scrolloff, 0].max
    elsif (@pL.ix + page - 1 - @index) < scrolloff
      # If we're too close to the bottom of the pane, scroll down
      max_off = total - page
      @pL.ix = [@index + scrolloff - page + 1, max_off].min
    end
    @min_index = 0
    @max_index = total - 1
    @index     = 0          if @index.negative?
    @index     = @max_index if @index > @max_index
    @pL.refresh unless @pL.text == lefttext
  end

  # RIGHT pane {{{3
  if @pR.update && @preview
    showimage('clear') if @image; @image = false
    righttext = @pR.text
    if @selected && File.directory?(@selected)
      @pR.text = dirlist(left: false)
    else
      showcontent
    end
    @pR.full_refresh unless @pR.text == righttext || @image
  end

  # TOP PANE {{{3
  if @pT.update
    toptext = @pT.text
    text = ' ' + ENV.fetch('USER') + '@' + `hostname 2>/dev/null`.chomp + ': '
    unless @selected.nil?
      text += @selected
      text += " → #{File.readlink(@selected)}" if File.symlink?(@selected)
    end
    # File attributes
    text += " (#{@fileattr})" if defined?(@fileattr)
    # Image or PDF metadata
    begin
      if @selected&.match(@imagefile)
        if cmd?('identify')
          meta = `identify -format " [%wx%h %m %[colorspace] %[bit-depth]-bit]" #{Shellwords.escape(@selected)} 2>/dev/null`
          text += meta
        end
      elsif @selected&.match(@pdffile)
        info  = `pdfinfo #{Shellwords.escape(@selected)} 2>/dev/null`
        pages = info[/^Pages:\s+(\d+)/, 1]
        size  = info[/^Page size:.*\((.*)\)/, 1]
        text += " [#{pages} pages]" if pages
        text += " [#{size}]"         if size
      end
    rescue Errno::ENOENT, Errno::EACCES
      # ignore missing or permission errors
    end
    # Directory children count
    if @selected && Dir.exist?(@selected)
      begin
        count = Dir.children(@selected).count
        text += " [#{count} items]"
      rescue Errno::EACCES
        text += ' [Denied]'
      end
    end
    @pT.text = text.b
    @pT.bg   = @topmatch.find { |name, _| name.empty? || Dir.pwd.include?(name) }&.last
    @pT.refresh unless @pT.text == toptext
  end

  # BOTTOM pane {{{3
  if @pB.update
    bottomtext = @pB.text
    info = ': for command (use @s for selected item, @t for tagged items) - press ? for help'
    info = " Showing only files matching '#{@lsmatch}'".fg(130).u if @lsmatch != ''
    info = " Showing only file type '#{@lsfiles}'".fg(129).u if @lsfiles != ''
    info = " Showing only file types '#{@lsfiles}'".fg(129).u if @lsfiles =~ /,/
    info += " and only files matching '#{@lsmatch}'".fg(129).u if @lsfiles != '' && @lsmatch != ''
    @pB.text = info
    @pB.refresh unless @pB.text == bottomtext
  end
end

def refresh # {{{2
  @p0.w = @w
  @p0.h = @h
  @p0.clear
  @pT.w = @w
  @pT.clear; @pT.update = true
  @pB.w = @w
  @pB.y = @h
  @pB.clear; @pB.update = true
  @pL.w = (@w - 4) * @width / 10
  @pL.h = @h - 4
  @pR.x = @pL.w + 4
  @pR.w = @w - @pL.w - 4
  @pR.h = @h - 4
  @pL.clear; @pL.update = true
  @pR.clear; @pR.update = true
  @pCmd.y = @h
  @pCmd.w = @w
  @pRuby.y = @h
  @pRuby.w = @w
end

def setborder # {{{2
  case @border
  when 0
    @pL.border = false
    @pR.border = false
  when 1
    @pL.border = false
    @pR.border = true
  when 2
    @pL.border = true
    @pR.border = true
  when 3
    @pL.border = true
    @pR.border = false
  end
  refresh
end

def errormsg(msg, err) # {{{2 
  text  = "#{msg}: #{err.class} – #{err.message}\n\n".fg(196)
  err.backtrace.each { |ln| text += "  #{ln}\n" } # Full backtrace
  text += "\nPlease report error as an RTFM issue: https://github.com/isene/RTFM/issues"
  @pR.say(text)
end

def shell(cmd, background: false, err: nil) # {{{2
  # if caller passed err: filename, use that, otherwise fall back to the default log in /tmp
  tmp = err || File.join(Dir.tmpdir, 'rtfm_err.log')
  # build the full command, redirecting stderr to tmp
  full = if background
           "#{cmd} 2>#{tmp} &"
         else
           "#{cmd} 2>#{tmp}"
         end
  system(full)
  if File.exist?(tmp) # if anything was written, show it in @pR
    sleep 0.1
    err_text = File.read(tmp)
    unless err_text.strip.empty?
      @pR.say(err_text.fg(196))
      @pR.update = false
    end
    File.delete(tmp)
  end
  nil
end

def shellexec(cmd, timeout: 10) # {{{2
  out, err = command(cmd, timeout: timeout, return_both: true)
  @pR.say(err.fg(196)) unless err.empty?
  @pR.say(out) unless out.empty?
  @pB.full_refresh
end

def command(cmd, timeout: 5, return_both: false) # {{{2
  # Run a shell command with timeout, drain pipes concurrently,
  # and optionally return both stdout+stderr instead of auto-saying stderr
  #
  # @param cmd [String] the command to run via `bash -c`
  # @param timeout [Numeric, nil] seconds to wait (nil = wait forever)
  # @param return_both [Boolean] if true, return [stdout, stderr] instead of auto-saying
  # @return [String] stdout (when return_both: false)
  # @return [Array<String,String>] [stdout, stderr] (when return_both: true)
  cmd_array = ['bash', '-c', cmd]
  out_buf = String.new
  err_buf = String.new
  begin
    Open3.popen3(*cmd_array) do |_stdin, stdout, stderr, wait_thr|
      pid = wait_thr.pid
      # Drain both pipes in background threads
      out_reader = Thread.new { out_buf << stdout.read until stdout.eof? }
      err_reader = Thread.new { err_buf << stderr.read until stderr.eof? }
      if timeout
        unless wait_thr.join(timeout)
          # Timed out → kill everything
          Process.kill('TERM', pid) rescue nil
          sleep 0.1
          Process.kill('KILL', pid) rescue nil
          Process.wait(pid) rescue nil
          out_reader.kill
          err_reader.kill
          showimage('clear') if @image
          @pR.say('Error: Command timed out.'.fg(196))
          return return_both ? ['', "Error: Command timed out.\n"] : ''
        end
      else
        wait_thr.join
      end
      # Ensure we've captured all output
      out_reader.join
      err_reader.join
    end
    if return_both
      [out_buf, err_buf]
    else
      @pR.say(err_buf.fg(196)) unless err_buf.empty?
      out_buf
    end
  rescue IOError => e
    msg = "Error: Stream closed – #{e.message}\n"
    if return_both
      ['', msg]
    else
      showimage('clear') if @image
      @pR.say(msg.fg(196))
      ''
    end
  rescue => e
    msg = "Error: #{e.message}\n#{e.backtrace.join("\n")}\n"
    if return_both
      ['', msg]
    else
      @pR.say(msg.fg(196))
      ''
    end
  end
end

def copy_move_link(type) # COPY OR MOVE TAGGED ITEMS {{{2
  @tagged.uniq!
  @tagged.each do |item|
    dest = File.join(Dir.pwd, File.basename(item))
    dest += '1' if File.exist?(dest)
    while File.exist?(dest)
      # Replace the last character (presumed to be a digit) by incrementing it
      dest = dest.chop + (dest[-1].to_i + 1).to_s
    end
    begin
      case type
      when 'copy'
        FileUtils.cp_r(item, dest)
        @pB.say(' Item(s) copied here.')
      when 'move'
        FileUtils.mv(item, dest)
        @pB.say(' Item(s) moved here.')
      when 'link'
        FileUtils.ln_s(item, dest)
        @pB.say(' Item(s) symlinked here.')
      end
    rescue => e
      @pB.say(e.to_s)
    end
  end
  @tagged = []
  render
end

def mark_latest # UPDATE MARKS LIST {{{2
  @marks['5'] = @marks['4']
  @marks['4'] = @marks['3']
  @marks['3'] = @marks['2']
  @marks['2'] = @marks['1']
  @marks['1'] = @marks["'"]
  @marks["'"] = Dir.pwd
end

def get_interactive_program(file_path) # HELPER FOR OPEN_SELECTED TO USE @interactive {{{2
  begin
    inter_list = (@interactive || '').split(',').map(&:strip)
    if @runmailcap
      # Check what run-mailcap would execute. Use --norun to see the command without executing it
      mailcap_output = `run-mailcap --norun #{Shellwords.escape(file_path)} 2>/dev/null`.chomp
      if !mailcap_output.empty?
        # Extract the program name from the command
        # Handle cases like "/usr/bin/mplayer file.mp4" or "mplayer %s"
        cmd_parts = mailcap_output.split
        prog = cmd_parts.first
        prog = File.basename(prog) if prog
        return prog if prog && inter_list.include?(prog)
      end
    else
      # Check what xdg-open would use
      mimetype = `file --mime-type -b #{Shellwords.escape(file_path)}`.chomp
      desktop_file = `xdg-mime query default #{Shellwords.escape(mimetype)}`.chomp
      
      if desktop_file && !desktop_file.empty?
        # Read the desktop file to get the actual command
        desktop_path = nil
        ['/usr/share/applications/', '/usr/local/share/applications/', 
         File.join(Dir.home, '.local/share/applications/')].each do |dir|
          path = File.join(dir, desktop_file)
          if File.exist?(path)
            desktop_path = path
            break
          end
        end
        if desktop_path
          content = File.read(desktop_path)
          exec_line = content[/^Exec=(.*)$/m, 1]
          if exec_line
            # Extract the program name (first word, remove path)
            prog = exec_line.split.first
            prog = File.basename(prog) if prog
            return prog if prog && inter_list.include?(prog)
          end
        end
      end
    end
  rescue
    # If detection fails, fall back to normal behavior
  end
  nil
end

def open_selected(html = nil) # OPEN SELECTED FILE {{{2
  require 'tmpdir' unless Dir.respond_to?(:tmpdir)
  if File.directory?(@selected) # Dir? just cd into it
    mark_latest
    Dir.chdir(@selected) rescue nil
    return
  end
  
  # Check if this file should use an interactive program (same as § prefix logic)
  if !html && (prog = get_interactive_program(@selected))
    cmd = "#{prog} #{Shellwords.escape(@selected)}"
    # Use exactly the same logic as command_mode with § prefix (force interactive)
    # Restore shell tty so Ctrl-C/D work
    system("stty #{ORIG_STTY} < /dev/tty")
    # Clear to top-left
    system('clear < /dev/tty > /dev/tty')
    Cursor.show
    # Spawn on real tty
    pid = Process.spawn(cmd,
                       in:  '/dev/tty',
                       out: '/dev/tty',
                       err: '/dev/tty')
    begin
      Process.wait(pid)
    rescue Interrupt
      Process.kill('TERM', pid) rescue nil
      retry
    end
    # Restore raw/no-echo for RTFM
    system('stty raw -echo isig < /dev/tty')
    $stdin.raw!
    $stdin.echo = false
    Cursor.hide
    Rcurses.clear_screen
    refresh
    render
    return
  end
  tmpfile = File.join(Dir.tmpdir, 'rtfm_err.log')
  paths   = (@tagged + [@selected]).uniq
  if html # html mode - open in HTML-browser
    esc = paths.map { |p| Shellwords.escape(p) }.join(' ')
    shell("xdg-open #{esc} &", err: tmpfile)
    Rcurses.clear_screen; refresh; render
    if File.exist?(tmpfile)
      sleep 0.5
      err = File.read(tmpfile)
      showimage('clear') if @image
      @pR.say(err.fg(196))
      File.delete(tmpfile)
    end
    return
  end
  if File.read(@selected).force_encoding('UTF-8').valid_encoding? # Pure text
    system("stty #{ORIG_STTY} < /dev/tty")
    # Clear to top-left
    system('clear < /dev/tty > /dev/tty')
    Cursor.show
    editor = ENV.fetch('EDITOR', 'vi')      # Launch $EDITOR on the real TTY
    system("#{editor} #{Shellwords.escape(@selected)}")
    $stdin.raw!
    $stdin.echo = false
    Cursor.hide
    Rcurses.clear_screen # Redraw RTFM
    refresh
    render
    return
  end
  if @runmailcap # Open with run-mailcap or xdg-open
    arg = paths.map { |p| Shellwords.escape(p) }.join(' ')
    shell("run-mailcap #{arg} &", err: tmpfile)
  else
    shell("xdg-open #{Shellwords.escape(@selected)} &", err: tmpfile)
  end
  # Clean up
  Rcurses.clear_screen; refresh; render
  if File.exist?(tmpfile)
    sleep 0.5
    err = File.read(tmpfile)
    showimage('clear') if @image
    @pR.say(err.fg(196))
    File.delete(tmpfile)
  end
end

def conf_write(all: false) # WRITE TO ~/.rtfm/conf {{{2
  @conf = @conf.dup # work on a mutable copy
  assignments = {
    'marks'       => "@marks       = #{@marks}",
    'hash'        => "@hash        = #{@hash}",
    'history'     => "@history     = #{@pCmd.history.reverse.uniq.reverse.last(40)}",
    'rubyhistory' => "@rubyhistory = #{@pRuby.history.reverse.uniq.reverse.last(40)}",
    'aihistory'   => "@aihistory   = #{@pAI.history.reverse.uniq.reverse.last(40)}"
  }
  if all
    assignments.merge!(
      'lslong'      => "@lslong      = '#{@lslong}'",
      'lsall'       => "@lsall       = '#{@lsall}'",
      'lsorder'     => "@lsorder     = '#{@lsorder}'",
      'lsinvert'    => "@lsinvert    = '#{@lsinvert}'",
      'width'       => "@width       = #{@width}",
      'border'      => "@border      = #{@border}",
      'preview'     => "@preview     = #{@preview}",
      'trash'       => "@trash       = #{@trash}",
      'interactive' => "@interactive = '#{@interactive}'"
    )
  end
  assignments.each do |var, line| # For each var, replace its line or append if missing
    regex = /^@#{Regexp.escape(var)}\b.*$/
    if @conf.match?(regex)
      @conf.sub!(regex, line)
    else
      @conf << "\n" unless @conf.end_with?("\n")
      @conf << line << "\n"
    end
  end
  show_config
  @pB.say('Configuration written to ~/.rtfm/conf')
  File.write(CONFIG_FILE, @conf)
end

def exit_rtfm # CLEAN EXIT {{{2
  # If invoked with a stub filename, write out our cwd
  if ARGV[0]
    begin
      File.write(ARGV[0], Dir.pwd)
    rescue StandardError # rubocop:disable Lint/SuppressedException
    end
  end
  # Also record for the 'r' launcher
  last = File.join(Dir.home, '.rtfm_last_dir')
  begin
    File.write(last, Dir.pwd)
  rescue StandardError
    # ignore write errors
  end
  exit(0)
end

def log(msg) # LOG TO LOGFILE {{{2
  File.write(LOG_PATH, "#{Time.now.iso8601} #{msg}\n", mode: 'a')
end

# RIGHT PANE FUNCTIONS {{{1
def showcommand(cmd) # Helper function for showcontent {{{2
  c = command(cmd)
  return if c == ''

  @pR.say(c)
end

def showcontent # SHOW CONTENTS IN THE RIGHT WINDOW {{{2
  if @pR.update
    showimage('clear') if @image
    @image = false
    @pR.clear
  end
  begin
    if @selected && File.directory?(@selected)
      @pR.say(dirlist(left: false))
    else # Look up first matching handler
      entry = PREVIEW_HANDLERS.find { |re, _| re.match?(@selected) }
      pattern, tmpl = entry || [nil, nil]
      if tmpl   # Command-based preview
        escaped = Shellwords.escape(@selected)
        if !@batuse && tmpl.match?(/\b#{@bat}\b/)
          showcommand("cat #{escaped}")
        else
          cmd = tmpl.gsub('@s', escaped)
          showcommand(cmd)
        end
      elsif pattern # Nil template → image or video
        case @selected
        when /\.(?:png|jpe?g|bmp|gif|webp|tiff?)$/i
          showimage(Shellwords.escape(@selected))
          @image = true
        when /\.(?:mpg|mpeg|avi|mov|mkv|mp4)$/i
          tn = '/tmp/rtfm_video_tn.jpg'
          showcommand("ffmpegthumbnailer -s 1200 -i #{Shellwords.escape(@selected)} -o #{Shellwords.escape(tn)} 2>/dev/null")
          showimage(tn)
          @image = true
        else
          @pR.say("No preview available for #{@selected}")
        end
      else # Fallback: treat as text if UTF‑8
        text = File.read(@selected).force_encoding('UTF-8') rescue ''
        if text.valid_encoding?
          if @batuse
            begin
              showcommand("#{@bat} -n --color=always #{Shellwords.escape(@selected)}")
            rescue
              showcommand("cat #{Shellwords.escape(@selected)}")
            end
          else
            showcommand("cat #{Shellwords.escape(@selected)}")
          end
        else
          @pR.say("No preview available for #{@selected}")
        end
      end
    end
  rescue StandardError => e
    errormsg("⚠ Error while previewing #{@selected}", e)
  end
  @pR.update = false
end

def showimage(image) # SHOW THE SELECTED IMAGE IN THE RIGHT WINDOW {{{2
  # Pass 'clear' to clear the window for previous image
  return unless @showimage

  begin
    terminfo    = `xwininfo -id $(xdotool getactivewindow 2>/dev/null) 2>/dev/null`
    term_w      = terminfo.match(/Width: (\d+)/)[1].to_i
    term_h      = terminfo.match(/Height: (\d+)/)[1].to_i
    char_w      = term_w / @w
    char_h      = term_h / @h
    img_x       = char_w * @pR.x
    img_y       = char_h * 2
    img_max_w   = char_w * (@pR.w - 2)
    img_max_h   = char_h * (@pR.h - 1)
    if image == 'clear'
      `clear`
      img_x     -= char_w
      img_max_w += char_w + 2
      img_max_h += 2
      `echo "6;#{img_x};#{img_y};#{img_max_w};#{img_max_h};\n4;\n3;" | #{@imgdisplay} 2>/dev/null`
    else
      # Use the already-escaped image for shell commands
      dimensions = `identify -format "%wx%h" #{image} 2>/dev/null`
      img_w, img_h = dimensions.split('x').map(&:to_i)

      # Fix: Use simultaneous scaling to prevent overflow
      if img_w > img_max_w || img_h > img_max_h
        scale_w = img_max_w.to_f / img_w
        scale_h = img_max_h.to_f / img_h
        scale = [scale_w, scale_h].min

        img_w = (img_w * scale).to_i
        img_h = (img_h * scale).to_i
      end

      # Fix: Unescape the filename for w3mimgdisplay protocol, then quote it
      unescaped = image.gsub(/\\(.)/, '\1')  # Remove shell escaping
      `echo "0;1;#{img_x};#{img_y};#{img_w};#{img_h};;;;;\"#{unescaped}\"\n4;\n3;" | #{@imgdisplay} 2>/dev/null`
    end
  rescue
    @pR.text = 'Error showing image'
  end
end

def marks_info # SHOW MARKS IN RIGHT WINDOW {{{2
  @marks = @marks.sort.to_h
  info = ' ' + 'MARKS'.u + ":\n\n"
  if @marks.empty?
    info += ' (none)'
  else
    @marks.each do |mark, dir|
      info += " #{mark} = #{dir}\n"
      info += "\n" if mark == "'"
      info += "\n" if mark == '5'
    end
  end
  @pR.say(info.fg(156))
end

def tagged_info # SHOW THE LIST OF TAGGED ITEMS IN @pR {{{2
  info = ' ' + "TAGGED (#{@tagged.size} items, #{(@tagsize.to_f / 1_000_000).round(2)}MB)".u + ":\n\n"
  info += @tagged.empty? ? ' (None)' : ' ' + @tagged.join("\n ")
  info += "\n\n " + 'Selected'.u + ":\n " + @selected.b
  @pR.say(info.fg(204))
end

# MAIN PROGRAM {{{1
## Get terminal size {{{2
@h, @w = IO.console.winsize

## Create panes {{{2
# rubocop:disable Naming/VariableName
# p = Pane.new(        x,  y,              width, height,  fg,           bg)
@p0 = Pane.new(        1,  1,                 @w,     @h,   0,            0)
@pT = Pane.new(        1,  1,                 @w,      1,   0,    @topcolor)
@pB = Pane.new(        1, @h,                 @w,      1, 252, @bottomcolor)
@pL = Pane.new(        2,  3, (@w - 4)*@width/10, @h - 4,  15,            0)
@pR = Pane.new(@pL.w + 4,  3,     @w - @pL.w - 4, @h - 4, 255,            0)
## Create special panes
@pCmd    = Pane.new( 1, @h, @w, 1, 255,    @cmdcolor)
@pSearch = Pane.new( 1, @h, @w, 1, 255, @searchcolor)
@pRuby   = Pane.new( 1, @h, @w, 1, 255,   @rubycolor)
@pAI     = Pane.new( 1, @h, @w, 1, 255,     @aicolor)
# rubocop:enable Naming/VariableName
#checkpoint("Panes created")

## Set pane properties {{{2
@pT.update      = true
@pL.update      = true
@pR.update      = true
@pB.update      = true
@pSearch.record = true
@pCmd.record    = true
@pCmd.history   = @history
@pRuby.record   = true
@pRuby.history  = @rubyhistory
@pAI.record     = true
@pAI.history    = @aihistory

# Report plugin errors {{{2
@pR.say("Plugin load errors:\n" + @plugin_errors.join("\n").fg(196)) if @plugin_errors.any? 

## Set the borders {{{2
setborder

## Catch change in terminal resize, redraw {{{2
Signal.trap('WINCH') do 
  @h, @w = IO.console.winsize
  @pT.update = @pL.update = @pR.update = @pB.update = true
  refresh
  render
end


## One-time flush {{{2
$stdin.getc while $stdin.wait_readable(0)

## THE LOOP {{{2
#checkpoint("Program started")
loop do
  @dir_old = Dir.pwd
  # redraw, but ignore TTY‐focus errors
  begin
    render
  rescue Errno::EIO
    # nothing
  end
  # read key, but ignore TTY-focus errors
  begin
    getkey
  rescue Errno::EIO
    # nothing
  end
  # If cwd was deleted externally, jump home
  begin
    Dir.pwd
  rescue
    Dir.chdir
  end
  # restore index if we cd'd
  @index = @directory[Dir.pwd] || 0 if Dir.pwd != @dir_old
  unless @navi.empty?
    command(@navi)
    @navi = ''
  end
  system("printf \"\033]0;RTFM: #{Dir.pwd}\007\"") # Update window title
rescue StandardError => e
  errormsg('⚠ Internal Error', e)
end

# vim: set sw=2 sts=2 et fdm=marker fdn=2 fcs=fold\:\ :
