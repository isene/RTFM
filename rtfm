#!/usr/bin/env ruby
# encoding: utf-8

# Script info {{{1
# RTFM - [Ruby|Ruddy|Rough] Terminal File Manager
# Language:   Pure Ruby
# Author:     Geir Isene <g@isene.com>
# Web_site:   http://isene.com/
# Github:     https://github.com/isene/RTFM
# License:    I release all copyright claims. 
#             This code is in the public domain.
#             Permission is granted to use, copy modify, distribute, and
#             sell this software for any purpose. I make no guarantee
#             about the suitability of this software for any purpose and
#             I am not liable for any damages resulting from its use.
#             Further, I am under no obligation to maintain or extend
#             this software. It is provided on an 'as is' basis without
#             any expressed or implied warranty.
# }}}

# HELPTEXT {{{1
@help = <<HELPTEXT
RTFM - [Ruby|Ruddy|Rough] Terminal File Manager (https://github.com/isene/RTFM)

KEYS
  ?      = Show this help text
  DOWN   = Go one item down in left pane (rounds to top)
  UP     = Go one item up in left pane (rounds to bottom)
  PgDown = Go one page down in left pane
  PgUp   = Go one page up in left pane
  END    = Go to last item in left pane
  HOME   = Go to first item in left pane
  LEFT   = Go up one directory level
  RIGHT  = Enter directory or open file (using run-mailcap or xdg-open)
  TAB    = Next page of the preview (if doc long and ∇ in the bottom right)
  S-TAB  = Previous page (if you have moved down the document first - ∆ in the top right)
  a      = Show all (also hidden) items
  l      = Show long info per item (show item attributes)
  t      = Tag item (toggles)
  T      = Show currently tagged items in right pane
  u      = Untag all tagged items
  p      = Put (copy) tagged items here
  P      = PUT (move) tagged items here
  s      = Create symlink to tagged items here
  d      = Delete selected item and tagged items. Press 'd' to confirm
  c      = Change/rename selected (adds command to bottom window)
  m      = Mark current dir (persistent). Next letter is the name of the mark [a-zA-Z']
           Press '-' and a letter to delete that mark
  h      = Jump to Home directory
  '      = Jump to mark (next letter is the name of the mark [a-zA-Z'])
  M      = Show marked items in right pane
  H      = Show command history in right pane
  /      = Enter search string in bottom window to highlight matching items
  :      = Enter "command mode" in bottom window
  L      = Start 'locate' search for files, then use '#' to jump to desired line/directory
  ENTER  = Refresh RTFM
  q      = Quit

COPYRIGHT: Geir Isene, 2020. No rights reserved. See http://isene.com for more.
HELPTEXT
# }}}1

# BASIC SETUP {{{1
# Remove code warnings {{{2
Warning[:deprecated] = false

# Requires and loads {{{2
require 'fileutils'
require 'curses'
include Curses

if File.exist?(Dir.home+'/.rtfm.conf')
  load(Dir.home+'/.rtfm.conf')
else
  $marks = {}
  File.write((Dir.home+'/.rtfm.conf'), "$marks = {}\n")
end
# }}}
# Curses setup {{{2
Curses.init_screen
Curses.start_color
Curses.curs_set(0)
Curses.noecho
Curses.cbreak
Curses.stdscr.keypad = true
# }}}
# Set basic variables {{{2
STDIN.set_encoding(Encoding::UTF_8)
@w3mimgdisplay = "/usr/lib/w3m/w3mimgdisplay"
# }}}
# Set default colors {{{2
init_pair(7, 7, 0)        # Default
init_pair(232, 232, 249)  # Top Window
init_pair(250, 250, 0)    # Bottom Window
# }}}
# Import LS_COLORS {{{2
LScolors = `echo $LS_COLORS`
# }}}
# }}}1

# INITIALIZE VARIABLES {{{1
# Initialize the tagged array - for collecting all tagged items
@tagged = []

# Initialize the command line history
@history = []

# Initialize the active searched for items, 'info' and 'locate' variables
@searched  = ""

# Initialize the directory hash -
# for remembering index for every directory visited
@directory = {}

# Set chosen item to first
@index = 0

# Set short form ls (toggled by pressing "l")
@lslong = false

# Set "ls -a" to false (toggled by pressing "a")
@lsall = ""
# }}}1

# CLASS EXTENSIONS {{{1
class Curses::Window
  attr_accessor :update, :pager, :pager_more, :pager_cmd, :page_text, :locate, :nohistory 
  def clr
    self.setpos(0, 0)
    (self.maxy - self.cury).times {self.deleteln()}
    self.refresh
    self.setpos(0, 0)
  end
end
# }}}

# FUNCTIONS {{{1
## GENERIC {{{2
def get_ls_color(type) # {{{3
  # Get the color for the filetype from imported LS_COLORS
  bold  = 0
  begin
    color = LScolors.match(/#{type}=\d*;\d*;(\d*)/)[1]
    bold  = 1 if LScolors.match(/#{type}=\d*;\d*;\d*;1/)
  rescue
    color = 7
  end
  return color.to_i, bold
end

def color_parse(input) # {{{3
  input.gsub!( /\e\[\d;38;5;(\d+)m/, '%-%\1%-%')
  input.gsub!( /\e\[38;5;(\d+)m/, '%-%\1%-%')
  input.gsub!( /\e\[0m/, "\t")
  color_array = input.split("%-%")
  color_array = color_array.drop(1)
  output = color_array.each_slice(2).to_a
  return output
end

def list_dir(win, left, files)# {{{3
  # List content of a directory (both left and right windows)
  left ? ix = @index : ix = 0
  files.each.with_index(0) do |str, index|

    left ? str_path = str : str_path = "#{@selected}/#{str}" 
    # Ensure only the items fitting on the screen will be drawn (@win_left)
    if index > ix - win.maxy + 3
      # Determine the filetype of the item {{{4
      ftype = ""
      ftype = str.match(/\.([^.]*$)/)[1] if str.match?(/\.([^.]*$)/)
      
      # Set special filetypes (sequence matters)
      ftype = "bd" if File.blockdev?(str_path)
      ftype = "cd" if File.chardev?(str_path)
      ftype = "pi" if File.pipe?(str_path)
      ftype = "st" if File.sticky?(str_path)
      ftype = "so" if File.socket?(str_path)
      ftype = "ex" if File.executable?(str_path)
      ftype = "di" if File.directory?(str_path)
      ftype = "ln" if File.symlink?(str_path) 
      # Checking if item is an orphaned link
      begin
        File.stat(str_path)
      rescue
        ftype = "or" 
      end

      # Set the colors for the filetypes, print to window {{{4
      # Set default colors
      fg = 7; bold = 0; bg = 0
      
      # Get color for filetype from imported LS_COLORS
      fg, bold = get_ls_color(ftype) unless ftype == ""
      init_pair(fg, fg, bg)

      # Set color for the item and add "/" if directory
      file_marker = color_pair(fg)
      file_marker = file_marker | Curses::A_BOLD if bold == 1
      file_marker = file_marker | Curses::A_UNDERLINE if index == @index and left
      file_marker = file_marker | Curses::A_REVERSE if @tagged.include?("'#{Dir.pwd}/#{str_path}'")
      file_marker = file_marker | Curses::A_BLINK if str.match(/#{@searched}/) and @searched != ""
      File.directory?(str_path) ? dir = "/" : dir = ""
      File.symlink?(str_path) ? link = "@" : link = ""
      str = @fspes[index] + "  " + str if @lslong
      if str.length > win.maxx - 4
        base_name   = File.basename(str, ".*")
        base_length = base_name.length
        ext_name    = File.extname(str)
        ext_length  = ext_name.length
        nbl = win.maxx - 5 - ext_length # nbl: new_base_length
        str = base_name[0..nbl] + "…" + ext_name
      end
      
      # Implement the color (and bold), clear to end-of-line and add newline
      win.attron(file_marker) { win << str + link + dir }
      clrtoeol
      win << "\n"
    end
  end
end

def var_resets # {{{ 3
    @pager = 0
    @pager_more = false
    @pager_cmd = ""
    @info = false
end

def getchr # {{{3
  # Get key from user
  # Curses.getch blanks out @win_top
  # @win_left.getch makes Curses::KEY_DOWN etc not work
  # Therefore resorting to the generic method
  c = STDIN.getc
  case c
  when "\e" # ANSI escape sequences
    case $stdin.getc
    when '[' # CSI
      case $stdin.getc
      when 'A' then chr = "UP"
      when 'B' then chr = "DOWN"
      when 'C' then chr = "RIGHT"
      when 'D' then chr = "LEFT"
      when 'Z' then chr = "S-TAB"
      when '2' then chr = "INS"    ; STDIN.getc
      when '3' then chr = "DEL"    ; STDIN.getc
      when '5' then chr = "PgUP"   ; STDIN.getc
      when '6' then chr = "PgDOWN" ; STDIN.getc
      when '7' then chr = "HOME"   ; STDIN.getc
      when '8' then chr = "END"    ; STDIN.getc
      end
    end
  when "" then chr = "BACK"
  when "\r" then chr = "ENTER"
  when "\t" then chr = "TAB"
  when /./  then chr = c
  end
  return chr
end

def main_getkey # {{{3
  # Get key from user
  # Curses.getch blanks out @win_top
  # @win_left.getch makes Curses::KEY_DOWN etc not work
  # Therefore resorting to the generic method
  dir = Dir.pwd
  chr = getchr
  case chr
  when '?' # Show helptext in right window {{{4
    win_right_info(@help)
    @win_right.update = false
  when 'UP' # {{{4
    var_resets
    @index = @index <= @min_index ? @max_index : @index - 1
  when 'DOWN' # {{{4
    var_resets
    @index = @index >= @max_index ? @min_index : @index + 1
  when 'RIGHT' # {{{4
    var_resets
    # Store index of this directory before leaving
    @directory[Dir.pwd] = @index
    open_selected()
  when 'LEFT' # {{{4
    var_resets
    # Store index of this directory before leaving
    @directory[Dir.pwd] = @index
    Dir.chdir("..")
    # Set index to stored value if directory has been visited
    @directory.key?(Dir.pwd) ? @index = @directory[Dir.pwd] : @index = 0
  when 'PgUP' # {{{4
    var_resets
    @index -= @win_left.maxy - 2
    @index = @min_index if @index < @min_index
  when 'PgDOWN' # {{{4
    var_resets
    @index += @win_left.maxy - 2
    @index = @max_index if @index > @max_index
  when 'HOME' # {{{4
    var_resets
    @index = @min_index
  when 'END' # {{{4
    var_resets
    @index = @max_index
  when 'TAB' # {{{4
    # Start paging
    @win_right.page_text = `#{@win_right.page_cmd}` if @win_right.pager == 1 and @win_right.update == false
    if @win_right.pager_more
      @win_right.pager += 1
      pager_show 
    end
  when 'S-TAB' # {{{4
    # Up one page
    if @win_right.pager > 1
      @win_right.pager -= 1
      pager_show
    end
  when 'a'# Show all items {{{4
    @lsall == "" ? @lsall = "-a" : @lsall = ""
  when 'l' # Show long info for all items {{{4
    @lslong = !@lslong
  when 't' # Add item to tegged list {{{4
    item = "'#{Dir.pwd}/#{@selected}'"
    if @tagged.include?(item)
      @tagged.delete(item)
    else
      @tagged.push(item)
    end
    tagged_info
    @win_right.update = false
  # }}}4
  when 'T' # Show tagged list {{{4
    tagged_info
    @win_right.update = false
  # }}}4
  when 'u' # Clear tagged list {{{4
    @tagged = []
    tagged_info
    @win_right.update = false
  # }}}4
  when 'p' # Copy tagged items here {{{4
    copy_move_link("copy")
  # }}}4
  when 'P' # Move tagged items here {{{4
    copy_move_link("move")
  # }}}4
  when 's' # Create symlink to tagged items here {{{4
    copy_move_link("link")
  # }}}4
  when 'd' # Delete items tagged and @selected {{{4
    tagged_info
    win_bottom_info(" Delete selected and tagged? (press 'd' again to delete)")
    begin
      @tagged.push("'#{@selected}'")
      @tagged.uniq!
      deletes = @tagged.join(" ")
      `rm -rf #{deletes}` if STDIN.getc == 'd'
      items_number = @tagged.length
      @tagged = []
      win_bottom_info("Deleted #{items_number} items: #{deletes}")
    rescue StandardError => err
      win_bottom_info(err.to_s)
    end
  # }}}4
  when 'c' # Change/rename selected @selected {{{4
    cmd = win_bottom_getstr(": ", "mv \"#{@selected}\" \"#{@selected}\"")
    win_bottom_exec(cmd)
  # }}}4
  when 'm' # Set mark {{{4
    marks_info
    m = STDIN.getc
    if m.match(/[\w']/)
      $marks[m] = Dir.pwd
    elsif m == "-"
      r = STDIN.getc
      $marks.delete(r)
    end
    marks_info
    @win_right.update = false
  # }}}4
  when 'M' # Show marks {{{4
    marks_info
    @win_right.update = false
  # }}}4
  when 'H' # Show command history {{{4
    win_right_info("Command history (latest on top):\n\n" + @history.join("\n"))
    @win_right.update = false
  # }}}4
  when 'h' # {{{4
    var_resets
    # Store index of this directory before leaving
    @directory[Dir.pwd] = @index
    Dir.chdir
    @directory.key?(Dir.pwd) ? @index = @directory[Dir.pwd] : @index = 0
  when "'" # Jump to mark {{{4
    marks_info
    m = STDIN.getc
    if m.match(/[\w']/) and $marks[m]
      var_resets
      # Store index of this directory before leaving
      @directory[Dir.pwd] = @index
      Dir.chdir($marks[m]) 
      @directory.key?(Dir.pwd) ? @index = @directory[Dir.pwd] : @index = 0
    end
  # }}}4
  when '/' # Get search string to mark items that match # {{{4
    @win_bottom.nohistory = true
    win_bottom_info("/ ")
    @searched = win_bottom_getstr("/ ", "")
  # }}}4
  when 'L' # Run 'locate' and let user jump to a result (by '#') {{{4
    cmd = win_bottom_getstr(": ", "locate ")
    win_bottom_exec(cmd)
    @win_right.locate = true
  when '#' # {{{4
    if @win_right.locate
      jumpnr   = win_bottom_getstr("# ", "").to_i
      jumpline = @win_right.page_text.lines[jumpnr - 1]
      jumpdir  = jumpline[/\/[^\e]*/]
      unless Dir.exist?(jumpdir) 
        @searched = File.basename(jumpdir)
        jumpdir = File.dirname(jumpdir)
      end
      # Store index of this directory before leaving
      @directory[Dir.pwd] = @index
      Dir.chdir(jumpdir)
      @directory.key?(Dir.pwd) ? @index = @directory[Dir.pwd] : @index = 0
      @win_right.pager = 0
    end
  when ':' # Enter "command mode" in the bottom window - tries to execute the given command {{{4
    @win_right.nohistory = false
    cmd = win_bottom_getstr(": ", "")
    win_bottom_exec(cmd)
  when '?' # Display help text {{{4
    win_right_info(@help)
    @win_right.update = false
  when 'q' # Exit {{{4
    system("printf \"\033]0;#{Dir.pwd}\007\"")
    exit 0
  end
  unless chr == 'L' or chr =~ /TAB/
    @win_right.locate = false
    @win_right.pager  = 0
  end
  @win_right.update = true if dir != Dir.pwd
end
## }}}2
## WIN_TOP {{{2
def win_top_info() # {{{3
  # Show info in @win_top
  @win_top.setpos(0,0)
  toptext  = " Path: " + Dir.pwd + "/" + @selected
  toptext += " (#{File.readlink(@selected)})" if File.symlink?(@selected) 
  begin
    toptext += " (#{@fspes[@index].gsub(/ .* /, ' ')})" 
  rescue
  end
  toptext = toptext[1..(@win_top.maxx - 3)] + "…" if toptext.length + 3 > @win_top.maxx 
  toptext += " " * (@win_top.maxx - toptext.length) if toptext.length < @win_top.maxx
  init_pair(232, 232, 249)
  @win_top.attron(color_pair(232) | Curses::A_BOLD) { @win_top << toptext }
  @win_top.refresh
end

## }}}2
## WIN_LEFT {{{2
def open_selected() # {{{3
  # Open selected item (when pressing Right)
  if File.directory?(@selected) # Rescue for permission error
    begin
      Dir.chdir(@selected)
      # Set index to stored value if directory has been visited
      @directory.key?(Dir.pwd) ? @index = @directory[Dir.pwd] : @index = 0
    rescue
    end
  else
    begin
      if File.read(@selected).force_encoding("UTF-8").valid_encoding?
        system("$EDITOR #{@selected_safe}")
      else
          begin
            system("run-mailcap #{@selected_safe}")
          rescue
            system("xdg-open #{@selected_safe}")
          end
        end
      Curses.refresh
    rescue
    end
  end
end

def copy_move_link(type) # {{{3
  # Copy or move tagged items (copy if "keep == true")
  @tagged.uniq!
  @tagged.each do | item |
    item = item[1..-2]
    dest = Dir.pwd
    dest += "/" + File.basename(item)
    dest += "1" if File.exist?(dest)
    while File.exist?(dest)
      dest = dest.chop + (dest[-1].to_i + 1).to_s
    end
    begin
      case type
      when "copy"
        FileUtils.cp_r(item, dest)
      when "move"
        FileUtils.mv(item, dest)
      when "link"
        FileUtils.ln_s(item, dest)
      end
    rescue StandardError => err
      win_bottom_info(err.to_s)
    end
  end
  @tagged = [] if type == "move"
end

## }}}2
## WIN_RIGHT {{{2
def syntax_highlight(input) # {{{3
  # batcat syntax highlighting
  color_ary  = color_parse(input)
  color_ary.each do | pair |
    begin
      fg   = pair[0].to_i
      text = pair[1]
      text.gsub!(/\t/, '')
      init_pair(fg, fg, 0)
      @win_right.attron(color_pair(fg)) { @win_right << text }
    rescue
    end
  end
end

def pager_add_markers # {{{3
  # Add markers top/right & bottom/right to show paging as relevant
  if @win_right.pager > 1
    @win_right.setpos(0, @win_right.maxx - 1)
    @win_right << "∆"
  end
  if @win_right.pager_more
    @win_right.setpos(@win_right.maxy - 1, @win_right.maxx - 1)
    @win_right << "∇"
  end
end

def pager_start(input) # {{{3
  if input.lines.count > @win_right.maxy - 2
    @win_right.pager      = 1
    @win_right.pager_more = true
  end
end

def pager_show # {{{3
  @win_right.clr
  beg_l = (@win_right.pager - 1) * (@win_right.maxy - 3)
  end_l = beg_l + @win_right.maxy - 2
  input = @win_right.page_text.lines[beg_l..end_l].join() + "\n"
  input.lines.count > @win_right.maxy - 2 ? @win_right.pager_more = true : @win_right.pager_more = false
  if @win_right.pager_cmd.match(/batcat/)
    syntax_highlight(input)
  else
    @win_right << input
  end
  pager_add_markers
  @win_right.refresh
end

def image_show(image)# {{{3
  # Show the selected image in the right window (pass "clear" to clear the window)
  begin
    terminfo    = `xwininfo -id $(xdotool getactivewindow)`
    term_w      = terminfo.match(/Width: (\d+)/)[1].to_i
    term_h      = terminfo.match(/Height: (\d+)/)[1].to_i
    char_w      = term_w / Curses.cols
    char_h      = term_h / Curses.lines
    img_x       = char_w * (Curses.cols / 3 + 1)
    img_y       = char_h * 2
    img_max_w   = char_w * (2 * Curses.cols / 3 - 2)
    img_max_h   = char_h * (Curses.lines - 5)
    if image == "clear"
      img_max_w += 5
      img_max_h += 5
      `imgw3m.sh CLEAR #{img_x} #{img_y} #{img_max_w} #{img_max_h} 2>/dev/null`
    else
      img_w,img_h = `identify -format "%[fx:w]x%[fx:h]" #{image} 2>/dev/null`.split('x')
      img_w       = img_w.to_i
      img_h       = img_h.to_i
      if img_w > img_max_w
        img_h = img_h * img_max_w / img_w 
        img_w = img_max_w
      end
      if img_h > img_max_h
        img_w = img_w * img_max_h / img_h
        img_h = img_max_h
      end
      `imgw3m.sh #{image} #{img_x} #{img_y} #{img_w} #{img_h} 2>/dev/null`
      #w3m_cmd     = "0;1;#{img_x};#{img_y};#{img_w};#{img_h};;;;;#{image}\\n4;\\n3;"
      #`echo -e "#{w3m_cmd}"|#{@w3mimgdisplay}`
    end
  rescue
    @win_right << "Error showing image"
  end
end

def win_right_show # {{{3
  # Show contents in the right window
  # First clear the window
  @win_right.clr
  # Then clear any previously showing image
  image_show("clear")
  # Determine the specific programs to open/show content {{{4
  begin
    # Directories {{{5
    if @win_right.pager > 0
      pager_show 
    elsif File.directory?(@selected)
      ls_cmd = "ls #{@lsall} #{@selected_safe} --group-directories-first"
      files  = `#{ls_cmd}`.split("\n")
      ls_cmd   += %q[ -lh | awk '{printf "%s%4s%7s", $1,$2,$5"\n"}']
      @fspes    = `#{ls_cmd}`.split("\n").drop(1)
      list_dir(@win_right, false, files)
    # Text {{{5
    # View the file as text if it is utf-8
    elsif File.read(@selected).force_encoding("UTF-8").valid_encoding? and @win_right.pager == 0
      begin
        @win_right.pager_cmd = "batcat -n --color=always #{@selected_safe} 2>/dev/null"
        input      = `batcat -n --color=always --line-range :#{@win_right.maxy} #{@selected_safe} 2>/dev/null`
        pager_start(input)
        syntax_highlight(input)
      rescue
        @win_right.pager_cmd  = "cat #{@selected_safe} 2>/dev/null"
        input       = `#{@win_right.pager_cmd}`
        @win_right << input
        pager_start(input) 
      end
    # PDF {{{5
    elsif @selected.match(/\.pdf$|\.ps$/) and @win_right.pager == 0
      @win_right.pager_cmd  = "pdftotext #{@selected_safe} - 2>/dev/null | less"
      input =       `pdftotext -f 1 -l 4 #{@selected_safe} - 2>/dev/null | less`
      pager_start(input) 
      @win_right << input
    # Open/LibreOffice {{{5
    elsif @selected.match(/\.odt$|\.odc$|\.odp$|\.odg$/) and @win_right.pager == 0
      @win_right.pager_cmd  = "odt2txt #{@selected_safe} 2>/dev/null"
      input       = `#{@win_right.pager_cmd}`
      pager_start(input) 
      @win_right << input
    # OOXML {{{5
    elsif @selected.match(/\.docx$|\.xlsx$|\.pptx$/) and @win_right.pager == 0
      @win_right.pager_cmd  = "docx2txt #{@selected_safe} - 2>/dev/null"
      input       = `#{@win_right.pager_cmd}`
      pager_start(input) 
      @win_right << input
    # MS doc {{{5
    elsif @selected.match(/\.doc$/) and @win_right.pager == 0
      @win_right.pager_cmd  = "catdoc #{@selected_safe} 2>/dev/null"
      input       = `#{@win_right.pager_cmd}`
      pager_start(input) 
      @win_right << input
    # MS xls {{{5
    elsif @selected.match(/\.xls$/) and @win_right.pager == 0
      @win_right.pager_cmd  = "xls2csv #{@selected_safe} 2>/dev/null"
      input       = `#{@win_right.pager_cmd}`
      pager_start(input) 
      @win_right << input
    # MS ppt {{{5
    elsif @selected.match(/\.ppt$/) and @win_right.pager == 0
      @win_right.pager_cmd  = "catppt #{@selected_safe} 2>/dev/null"
      input       = `#{@win_right.pager_cmd}`
      pager_start(input) 
      @win_right << input
    # Images {{{5
    elsif @selected.match(/\.jpg$|\.jpeg$|\.png$|\.bmp$|\.gif$|\.tif$|\.tiff$/)
      image_show(@selected_safe)
    # Videos (thumbnails) {{{5
    elsif @selected.match(/\.mpg$|\.mpeg$|\.avi$|\.mov$|\.mkv$|\.mp4$/)
      begin
        tmpfile = "/tmp/" + File.basename(@selected_safe,".*")
        `ffmpegthumbnailer -s 1000 -i #{@selected_safe} -o /tmp/rtfm_video_tn.jpg`
        image_show("/tmp/rtfm_video_tn.jpg")
      rescue
      end
    end
  rescue
  end
  # Add page markers & refresh {{{ 5
  pager_add_markers
  @win_right.refresh
end

def win_right_info(info) # {{{3
  # Show info in the right window
  @win_right.setpos(0, 0)
  (@win_right.maxy - @win_right.cury).times {@win_right.deleteln()}
  @win_right.refresh
  # Clear for any previously showing image
  @win_right.setpos(0, 0)
  image_show("clear")
  @win_right << info + "\n"
  @win_right.refresh
end

def marks_info # {{{3
  # Show marks in right window
  info = "Marks:\n"
  unless $marks.empty?
    $marks.each do |mark, dir|
      info += "#{mark} = #{dir}\n"
    end
  else
    info += "(none)"
  end
  win_right_info(info)
end

def tagged_info # {{{3
  # Show the list of tagged items in @win_right
  info = "Tagged:\n"
  @tagged.empty? ? info += "(None)" : info += @tagged.join("\n")
  win_right_info(info)
end


## }}}2
## WIN_BOTTOM {{{2
def win_bottom_info(info) # {{{3
  # Show info in @win_bottom
  init_pair(250, 250, 0)
  @win_bottom.setpos(0,0)
  @win_bottom.attron(color_pair(250) | Curses::A_DIM) { @win_bottom << "─" * @win_bottom.maxx }
  @win_bottom.deleteln()
  info = ": for command (use @s for selected item, @t for tagged items)" if info == nil
  @win_bottom.attron(color_pair(250) | Curses::A_DIM) { @win_bottom << info }
  @win_bottom.refresh
  @win_bottom.update = false
end

def win_bottom_getstr(pretext, text) # {{{3
  # A simple Readline-like routine
  Curses.curs_set(1)
  Curses.echo
  stk = 0
  @history.insert(stk, text)
  pos = @history[stk].length
  chr = ""
  while chr != "ENTER"
    @win_bottom.setpos(1,0)
    @win_bottom << pretext + @history[stk]
    @win_bottom.clrtoeol
    @win_bottom.setpos(1,pretext.length + pos)
    @win_bottom.refresh
    chr = getchr
    case chr
    when 'UP'
      unless @win_bottom.nohistory
        unless stk == @history.length - 1
          stk += 1 
          pos = @history[stk].length
        end
      end
    when 'DOWN'
      unless @win_bottom.nohistory
        unless stk == 0
          stk -= 1 
          pos = @history[stk].length
        end
      end
    when 'RIGHT'
      pos += 1 unless pos > @history[stk].length
    when 'LEFT'
      pos -= 1 unless pos == 0
    when 'HOME'
      pos = 0
    when 'END'
      pos = @history[stk].length
    when 'DEL'
      @history[stk][pos] = ""
    when 'BACK'
      unless pos == 0
        pos -= 1
        @history[stk][pos] = ""
      end
    when /^.$/
      @history[stk].insert(pos,chr)
      pos += 1
    end
  end
  curstr = @history[stk]
  @history.shift if @win_bottom.nohistory
  unless @win_bottom.nohistory
    @history.uniq!
    @history.compact!
    @history.delete("")
  end
  Curses.curs_set(0)
  Curses.noecho
  return curstr
end

def win_bottom_exec(cmd) #{{{3
  # Execute command from @win_bottom
  # Subsitute any '@s' with the selected item, @t with tagged items
  # 'rm @s' deletes the selected item, 'rm @t' deletes tagged items
  return if cmd == ""
  @s = @selected
  cmd.gsub!(/@s/, @s)
  @t = @tagged.join(" ")
  cmd.gsub!(/@t/, @t)
  begin
    begin
      @win_right.pager_cmd = "#{cmd} | batcat -n --color=always"
      @win_right.page_text = `#{@win_right.pager_cmd}`
    rescue
      @win_right.page_text = `#{cmd}`
    end
    unless @win_right.page_text == ""
      image_show("clear")
      @win_right.setpos(0, 0)
      (@win_right.maxy - @win_right.cury).times {@win_right.deleteln()}
      pager_start(@win_right.page_text)
      pager_show
      @win_right.refresh
      @win_right.update = false
    end
  rescue
    win_bottom_info(" Failed to execute command (#{cmd})")
  end
end
## }}}2
# }}}1

# MAIN PROGRAM {{{1
begin
  # Create the four windows/panels {{{2
  # Curses::Window.new(h,w,y,x)
  maxx       = Curses.cols
  maxy       = Curses.lines
  @win_top    = Curses::Window.new(1, 0, 0, 0)
  @win_bottom = Curses::Window.new(2, 0, maxy - 2, 0)
  @win_left   = Curses::Window.new(maxy - 4, maxx / 3 - 1, 2, 1)
  @win_right  = Curses::Window.new(maxy - 4, maxx - maxx / 3 - 1, 2, maxx / 3 + 1)
  # Set all windows to update initially
  @win_top.update    = true
  @win_left.update   = true
  @win_right.update  = true
  @win_bottom.update = true
  # Set no pager for @win_right
  @win_right.pager      = 0
  @win_right.pager_more = false
  # }}}
  # Core loop {{{2
  loop do
    # Set Window title to path {{{3
    system("printf \"\033]0;RTFM: #{Dir.pwd}\007\"")

    # Get files in current directory, set selected item {{{3
    ls_cmd    = "ls #{@lsall} --group-directories-first"
    files     = `#{ls_cmd}`.split("\n")
    ls_cmd   += %q[ -lh | awk '{printf "%s%4s%7s", $1,$2,$5"\n"}']
    @fspes    = `#{ls_cmd}`.split("\n").drop(1)
    @selected = files[@index]
    @selected = "" if @selected == nil
    @selected_safe = "\"#{@selected}\""

    # Safety measure - correct index overflows {{{3
    @max_index = files.size - 1
    @min_index = 0
    @index = @max_index if @index > @max_index

    # Top window (info line) {{{3
    win_top_info

    # Left window (browser) {{{3
    @win_left.setpos(0,0)
    list_dir(@win_left, true, files)
    (@win_left.maxy - @win_left.cury).times {@win_left.deleteln()}
    @win_left.refresh

    # Right window (content viewer) {{{3
    win_right_show if @win_right.update

    # Bottom window (command line) {{{3
    win_bottom_info(nil) if @win_bottom.update

    # Set updates for all windows
    @win_top.update    = true
    @win_left.update   = true
    @win_right.update  = true
    @win_bottom.update = true

    # Clear residual cursor from editing files {{{3
    Curses.curs_set(1)
    Curses.curs_set(0)
    
    # Get key from user {{{3
    main_getkey
  end
# }}}2
# On exit: close curses, clear terminal {{{2
ensure
  conf = File.read(ENV['HOME']+'/.rtfm.conf')
  conf.sub!(/\$marks.*{.*?}/m, "$marks = #{$marks}")
  File.write(ENV['HOME']+'/.rtfm.conf', conf)
  close_screen
  # If RTFM was launched via the bash script "r", then return the current
  # directory so that "r" can cd to that directory
  if ARGV[0]
    File.write(ARGV[0], Dir.pwd) if ARGV[0].match(/\/tmp\/tmp/)
  end
end
# }}}1

# vim modeline {{{1
# vim: set sw=2 sts=2 et fdm=marker fillchars=fold\:\ :
